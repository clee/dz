<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractZoneController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Model Abstractions and Implementation</a> &gt; <a href="index.source.html" class="el_package">net.sf.dz3.device.model.impl</a> &gt; <span class="el_source">AbstractZoneController.java</span></div><h1>AbstractZoneController.java</h1><pre class="source lang-java linenums">package net.sf.dz3.device.model.impl;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import org.apache.logging.log4j.ThreadContext;

import net.sf.dz3.device.model.Thermostat;
import net.sf.dz3.device.model.ThermostatSignal;
import net.sf.dz3.device.model.ThermostatStatus;
import net.sf.dz3.device.model.ZoneController;
import net.sf.dz3.util.digest.MessageDigestCache;
import net.sf.jukebox.datastream.logger.impl.DataBroadcaster;
import net.sf.jukebox.datastream.signal.model.DataSample;
import net.sf.jukebox.datastream.signal.model.DataSink;
import net.sf.jukebox.jmx.JmxDescriptor;
import net.sf.jukebox.logger.LogAware;

/**
 * The zone controller abstraction.
 *
 * Implements the behavior common for all the zone controller, and provides
 * the template methods for the rest.
 *
 * @author Copyright &amp;copy; &lt;a href=&quot;mailto:vt@freehold.crocodile.org&quot;&gt;Vadim Tkachenko&lt;/a&gt; 2001-2018
 */
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">public abstract class AbstractZoneController extends LogAware implements ZoneController {</span>

    /**
     * Zone controller name.
     *
     * Necessary evil to allow instrumentation signature.
     */
    private final String name;

    /**
     * Instrumentation signature.
     */
    private final String signature;

    /**
     * Mapping from thermostat name to thermostat instance - needed to support the {@link #dataBrodacaster}.
     */
<span class="fc" id="L49">    private final Map&lt;String, Thermostat&gt; name2ts = new TreeMap&lt;String, Thermostat&gt;();</span>

    /**
     * All thermostats that are unhappy, including ones that are not {@link ThermostatStatus#isVoting() voting}.
     */
<span class="fc" id="L54">    protected final Map&lt;Thermostat, ThermostatSignal&gt; unhappy = new TreeMap&lt;Thermostat, ThermostatSignal&gt;();</span>

    /**
     * Thermostats that are both unhappy and {@link ThermostatStatus#isVoting() voting}.
     */
<span class="fc" id="L59">    protected final Map&lt;Thermostat, ThermostatSignal&gt; unhappyVoting = new TreeMap&lt;Thermostat, ThermostatSignal&gt;();</span>

    /**
     * Mapping from the thermostat to its current failure condition.
     *
     * As soon as a valid signal arrives from the thermostat, its entry is
     * removed from this map.
     */
<span class="fc" id="L67">    protected Map&lt;Thermostat, ThermostatSignal&gt; failed = new TreeMap&lt;Thermostat, ThermostatSignal&gt;();</span>

    /**
     * Last known signal map.
     */
<span class="fc" id="L72">    protected final Map&lt;Thermostat, ThermostatSignal&gt; lastKnownSignal = new TreeMap&lt;Thermostat, ThermostatSignal&gt;();</span>

<span class="fc" id="L74">    private final DataBroadcaster&lt;Double&gt; dataBrodacaster = new DataBroadcaster&lt;Double&gt;();</span>

    /**
     * Zone controller output signal, computed in {@link #stateChanged(Thermostat, ThermostatSignal)}.
     */
    private DataSample&lt;Double&gt; signal;

    /**
     * Create an instance with no connected thermostats.
     *
     * @param name Zone controller name.
     */
    public AbstractZoneController(String name) {

<span class="nc" id="L88">        this(name, null);</span>
<span class="nc" id="L89">    }</span>

    /**
     * Create an instance with connected thermostats.
     *
     * @param name Zone controller name.
     * @param sources Thermostats to use as signal sources.
     */
<span class="fc" id="L97">    public AbstractZoneController(String name, Set&lt;Thermostat&gt; sources) {</span>


<span class="fc" id="L100">        this.name = name;</span>
<span class="fc" id="L101">        signature = MessageDigestCache.getMD5(name).substring(0, 19);</span>

<span class="fc" id="L103">        signal = new DataSample&lt;Double&gt;(System.currentTimeMillis(), name, signature, 0d, null);</span>

<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (sources != null) {</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">            for (Iterator&lt;Thermostat&gt; i = sources.iterator(); i.hasNext(); ) {</span>

<span class="fc" id="L109">                Thermostat source = i.next();</span>
<span class="fc" id="L110">                source.addConsumer(this);</span>

<span class="fc" id="L112">                logger.info(&quot;Consumer: &quot; + source.getName() + &quot;: &quot; + source);</span>
<span class="fc" id="L113">                name2ts.put(source.getName(), source);</span>
<span class="fc" id="L114">            }</span>
        }
<span class="fc" id="L116">    }</span>

    @Override
    public void consume(DataSample&lt;ThermostatSignal&gt; signal) {

<span class="pc bpc" id="L121" title="2 of 4 branches missed.">        assert(signal != null);</span>

<span class="fc" id="L123">        Thermostat source = name2ts.get(signal.sourceName);</span>

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L126">            throw new IllegalArgumentException(&quot;Don't know anything about '&quot; + signal.sourceName + &quot;'&quot;);</span>
        }

<span class="fc" id="L129">        stateChanged(source, signal.sample);</span>
<span class="fc" id="L130">    }</span>

    private synchronized void stateChanged(Thermostat source, ThermostatSignal pv) {

<span class="fc" id="L134">        ThreadContext.push(&quot;stateChanged&quot;);</span>

        try {

<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if (logger.isTraceEnabled()) {</span>

                // DataSample.toString() is expensive,and DataSample is a component of ThermostatSignal

<span class="nc" id="L142">                logger.trace(&quot;Source: &quot; + source);</span>
<span class="nc" id="L143">                logger.trace(&quot;Signal: &quot; + pv);</span>
            }

<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (lastKnownSignal.get(source) == null) {</span>

                // Let's pretend the signal didn't change, this should trigger the downflow correctly
<span class="fc" id="L149">                lastKnownSignal.put(source, pv);</span>
            }

<span class="fc" id="L152">            checkError(source, pv);</span>
<span class="fc" id="L153">            boolean needBump = checkUnhappy(source, pv);</span>

<span class="fc" id="L155">            signal = computeDemand(pv.demand.timestamp, needBump);</span>

<span class="fc" id="L157">            stateChanged();</span>

<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (needBump) {</span>
<span class="fc" id="L160">                raise(source);</span>
            }

        } finally {
<span class="fc" id="L164">            lastKnownSignal.put(source, pv);</span>
<span class="fc" id="L165">            ThreadContext.pop();</span>
        }
<span class="fc" id="L167">    }</span>

    /**
     * Execute {@link Thermostat#raise() on every thermostat for this zone other than {@code source}.
     *
     * @param source Thermostat to exclude from the {@code raise()}.
     */
    private void raise(Thermostat source) {

<span class="fc" id="L176">        Set&lt;Thermostat&gt; tsSet = new TreeSet&lt;Thermostat&gt;(lastKnownSignal.keySet());</span>

        // It's already calling, no need to raise() it
<span class="fc" id="L179">        tsSet.remove(source);</span>

<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        for (Iterator&lt;Thermostat&gt; i = tsSet.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L182">            i.next().raise();</span>
        }
<span class="fc" id="L184">    }</span>

    private void checkError(Thermostat source, ThermostatSignal signal) {

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (signal.demand.isError()) {</span>

            // Faulty thermostat can't participate in the process,
            // its zone will be handled&quot;by default&quot; - damper
            // controller will take care of that

<span class="nc" id="L194">            unhappy.remove(source);</span>
<span class="nc" id="L195">            unhappyVoting.remove(source);</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (!failed.containsKey(source)) {</span>

                // This is a fresh failure
<span class="nc" id="L200">                logger.error(&quot;FIXME: process the error:&quot; + signal);</span>
<span class="nc" id="L201">                failed.put(source, signal);</span>
            }

        } else {

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (failed.containsKey(source)) {</span>

                // Failure has cleared
<span class="nc" id="L209">                logger.info(&quot;Cleared failure condition for &quot; + source);</span>
<span class="nc" id="L210">                failed.remove(source);</span>
            }
        }
<span class="fc" id="L213">    }</span>

    /**
     * See whether the thermostat is still calling.
     *
     * @param source Thermostat whose signal is being considered.
     * @param signal Thermostat signal.
     *
     * @return {@code true} if this signal indicates a need to bump the HVAC
     * into &quot;running&quot; state (and possibly other thermostats into &quot;calling&quot; state).
     */
    private boolean checkUnhappy(Thermostat source, ThermostatSignal signal) {

<span class="fc" id="L226">        ThreadContext.push(&quot;checkUnhappy&quot;);</span>

        try {

<span class="fc" id="L230">            int calling = countCalling(unhappyVoting.values());</span>

            // Old signal is no longer relevant
<span class="fc" id="L233">            unhappy.remove(source);</span>
<span class="fc" id="L234">            unhappyVoting.remove(source);</span>

<span class="pc bpc" id="L236" title="1 of 2 branches missed.">            if (signal.demand.isError()) {</span>

                // Faulty thermostat can't participate in the process,
                // its zone will be handled&quot;by default&quot; - damper
                // controller will take care of that
                //
                // (This should've been taken care of by checkError(), but
                // let's be paranoid)
<span class="nc" id="L244">                return false;</span>
            }

<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (signal.calling) {</span>

<span class="fc" id="L249">                unhappy.put(source, signal);</span>

<span class="pc bpc" id="L251" title="1 of 2 branches missed.">                if (signal.voting) {</span>

<span class="fc" id="L253">                    unhappyVoting.put(source, signal);</span>

                    // Now let's see if the bump is required

<span class="fc bfc" id="L257" title="All 2 branches covered.">                    if (calling == 0) {</span>

                        // Yep, that's the first voting thermostat

<span class="fc" id="L261">                        logger.info(&quot;This HVAC run was initiated by &quot; + source.getName());</span>

<span class="fc" id="L263">                        return true;</span>
                    }
                }
            }


<span class="fc" id="L269">            return false;</span>

        } finally {
<span class="fc" id="L272">            ThreadContext.pop();</span>
        }
    }

    /**
     *
     * @param signalSet Set of thermostat signals to count the calling status for.
     *
     * @return Number of signals with calling bit set.
     */
    private int countCalling(Collection&lt;ThermostatSignal&gt; signalSet) {

<span class="fc" id="L284">        int count = 0;</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (Iterator&lt;ThermostatSignal&gt; i = signalSet.iterator(); i.hasNext(); ) {</span>

<span class="fc" id="L288">            ThermostatSignal signal = i.next();</span>

<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            count += signal.calling ? 1 : 0;</span>
<span class="fc" id="L291">        }</span>

<span class="fc" id="L293">        return count;</span>
    }

    /**
     * Compute the total zone controller demand.
     *
     * @param timestamp Last signal's timestamp.
     * @param needBump {@code true} if the unit needs to be kicked on.
     *
     * @return Total demand for this zone controller.
     */
    private DataSample&lt;Double&gt; computeDemand(long timestamp, boolean needBump) {

<span class="fc" id="L306">        ThreadContext.push(&quot;computeDemand&quot;);</span>

        try {

<span class="fc bfc" id="L310" title="All 4 branches covered.">            if (Double.compare(signal.sample, 0d) == 0 &amp;&amp; !needBump) {</span>

                // Nobody's calling yet, demand is irrelevant
<span class="fc" id="L313">                return new DataSample&lt;Double&gt;(timestamp, name, signature, 0d, null);</span>
            }

<span class="fc" id="L316">            double demandVoting = 0;</span>

            // Calculate demand for voting zones only for now

<span class="fc bfc" id="L320" title="All 2 branches covered.">            for (Iterator&lt;Entry&lt;Thermostat, ThermostatSignal&gt;&gt; i = unhappyVoting.entrySet().iterator(); i.hasNext();) {</span>

<span class="fc" id="L322">                Entry&lt;Thermostat, ThermostatSignal&gt; entry = i.next();</span>
<span class="fc" id="L323">                ThermostatSignal signal = entry.getValue();</span>

<span class="fc" id="L325">                demandVoting += signal.demand.sample;</span>
<span class="fc" id="L326">            }</span>

<span class="fc" id="L328">            logger.debug(&quot;Voting demand: &quot; + demandVoting);</span>

            // Let's see what non-voting zones say

<span class="fc" id="L332">            double demandTotal = 0;</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">            for (Iterator&lt;Entry&lt;Thermostat, ThermostatSignal&gt;&gt; i = unhappy.entrySet().iterator(); i.hasNext();) {</span>

<span class="fc" id="L336">                Entry&lt;Thermostat, ThermostatSignal&gt; entry = i.next();</span>
<span class="fc" id="L337">                ThermostatSignal signal = entry.getValue();</span>

<span class="fc" id="L339">                demandTotal += signal.demand.sample;</span>
<span class="fc" id="L340">            }</span>

<span class="fc" id="L342">            logger.debug(&quot;Total demand: &quot; + demandVoting);</span>

            // Bigger demand value wins
            // Just make sure voting and non-voting demand point in the same direction

<span class="pc bpc" id="L347" title="2 of 4 branches missed.">            if (demandVoting * demandTotal &gt;= 0 &amp;&amp; Math.abs(demandTotal) &gt; Math.abs(demandVoting)) {</span>

<span class="nc" id="L349">                logger.debug(&quot;Final demand: &quot; + demandTotal);</span>
<span class="nc" id="L350">                return new DataSample&lt;Double&gt;(timestamp, name, signature, demandTotal, null);</span>

            } else {

<span class="fc" id="L354">                logger.debug(&quot;Final demand: &quot; + demandVoting);</span>
<span class="fc" id="L355">                return new DataSample&lt;Double&gt;(timestamp, name, signature, demandVoting, null);</span>
            }

        } finally {
<span class="fc" id="L359">            ThreadContext.pop();</span>
        }
    }

    private void stateChanged() {

<span class="fc" id="L365">        dataBrodacaster.broadcast(signal);</span>
<span class="fc" id="L366">    }</span>

    @Override
    public String toString() {

<span class="fc" id="L371">        StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L373">        sb.append(&quot;&lt;&quot;);</span>
<span class="fc" id="L374">        renderString(sb);</span>
<span class="fc" id="L375">        sb.append(&quot;&gt;&quot;);</span>

<span class="fc" id="L377">        return sb.toString();</span>
    }

    protected void renderString(StringBuilder sb) {

<span class="fc" id="L382">        sb.append(&quot;signals: &quot;).append(lastKnownSignal).append(&quot;, &quot;);</span>

<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (!failed.isEmpty()) {</span>
<span class="nc" id="L385">            sb.append(&quot;failed: &quot;).append(failed).append(&quot;, &quot;);</span>
        }

<span class="fc" id="L388">        sb.append(&quot;unhappy: &quot;).append(unhappy).append(&quot;, &quot;);</span>
<span class="fc" id="L389">        sb.append(&quot;unhappyVoting: &quot;).append(unhappyVoting).append(&quot;, &quot;);</span>

<span class="fc" id="L391">        synchronized (this) {</span>
<span class="fc" id="L392">            sb.append(signal);</span>
<span class="fc" id="L393">        }</span>
<span class="fc" id="L394">    }</span>

    @Override
    public synchronized DataSample&lt;Double&gt; getSignal() {

<span class="fc" id="L399">        return signal;</span>
    }

    @Override
    public void addConsumer(DataSink&lt;Double&gt; consumer) {

<span class="nc" id="L405">        dataBrodacaster.addConsumer(consumer);</span>
<span class="nc" id="L406">    }</span>

    @Override
    public void removeConsumer(DataSink&lt;Double&gt; consumer) {

<span class="nc" id="L411">        dataBrodacaster.removeConsumer(consumer);</span>
<span class="nc" id="L412">    }</span>

    @Override
    public JmxDescriptor getJmxDescriptor() {

<span class="nc" id="L417">        return new JmxDescriptor(</span>
                &quot;dz&quot;,
                &quot;Zone Controller&quot;,
                name,
                &quot;Analyzes thermostat outputs and decides what to tell to the Unit&quot;);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>