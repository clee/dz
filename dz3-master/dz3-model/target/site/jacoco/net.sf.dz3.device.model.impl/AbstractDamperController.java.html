<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDamperController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Model Abstractions and Implementation</a> &gt; <a href="index.source.html" class="el_package">net.sf.dz3.device.model.impl</a> &gt; <span class="el_source">AbstractDamperController.java</span></div><h1>AbstractDamperController.java</h1><pre class="source lang-java linenums">package net.sf.dz3.device.model.impl;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.apache.commons.lang3.concurrent.BasicThreadFactory;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;

import net.sf.dz3.device.actuator.Damper;
import net.sf.dz3.device.model.DamperController;
import net.sf.dz3.device.model.Thermostat;
import net.sf.dz3.device.model.ThermostatSignal;
import net.sf.dz3.device.model.Unit;
import net.sf.dz3.device.model.UnitSignal;
import net.sf.dz3.instrumentation.Marker;
import net.sf.jukebox.datastream.signal.model.DataSample;
import net.sf.jukebox.datastream.signal.model.DataSink;
import net.sf.jukebox.jmx.JmxAttribute;
import net.sf.jukebox.jmx.JmxAware;
import net.sf.servomaster.device.model.TransitionStatus;

/**
 * Base logic for the damper controller.
 *
 * @author Copyright &amp;copy; &lt;a href=&quot;mailto:vt@homeclimatecontrol.com&quot;&gt;Vadim Tkachenko&lt;/a&gt; 2001-2020
 */
public abstract class AbstractDamperController implements DamperController, JmxAware {

<span class="fc" id="L39">    protected final Logger logger = LogManager.getLogger(getClass());</span>

    /**
     * Executor for asynchronous transitions.
     *
     * This pool requires exactly one thread.
     */
    private final ExecutorService executor;

    /**
     * Association from a thermostat to a damper.
     */
<span class="fc" id="L51">    private final Map&lt;Thermostat, Damper&gt; ts2damper = new HashMap&lt;&gt;();</span>

    /**
     * Association from a thermostat to its last known signal.
     */
<span class="fc" id="L56">    private final Map&lt;Thermostat, ThermostatSignal&gt; ts2signal = new TreeMap&lt;&gt;();</span>

    /**
     * Last known unit signal.
     */
<span class="fc" id="L61">    private DataSample&lt;UnitSignal&gt; hvacSignal = null;</span>

    /**
     * Instrumentation map.
     *
     * The only purpose is to be accessed via JMX ({@link #getDamperMap()}). Content is not used in any calculations.
     * Value is refreshed in {@link #shuffle(Map)}.
     */
<span class="fc" id="L69">    private final Map&lt;Damper, Double&gt; lastMap = new HashMap&lt;&gt;();</span>

    /**
     * Thermostat signal consumer.
     */
<span class="fc" id="L74">    private final ThermostatListener tsListener = new ThermostatListener();</span>

    /**
     * Mapping from thermostat name to thermostat instance - needed to support the {@link #tsListener}.
     */
<span class="fc" id="L79">    private final Map&lt;String, Thermostat&gt; name2ts = new TreeMap&lt;&gt;();</span>

    /**
     * Stays {@code true} until {@link #powerOff} is called.
     *
     * If this flag is {@code false} (i.e. {@link #powerOff} was called), all other methods will
     * throw {@link IllegalStateException} upon invocation
     */
<span class="fc" id="L87">    private boolean enabled = true;</span>

    /**
     * Create an instance and make it listen to the unit and thermostats.
     *
     * @param unit Unit to listen to.
     * @param ts2damper Thermostats to listen to and dampers to associate them with.
     */
<span class="fc" id="L95">    public AbstractDamperController(Unit unit, Map&lt;Thermostat, Damper&gt; ts2damper) {</span>

<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (unit == null) {</span>
<span class="nc" id="L98">            throw new IllegalArgumentException(&quot;unit can't be null&quot;);</span>
        }

<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (ts2damper == null) {</span>
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;ts2damper can't be null&quot;);</span>
        }

<span class="fc" id="L105">        executor = Executors.newSingleThreadExecutor(</span>
                new BasicThreadFactory.Builder()
<span class="fc" id="L107">                    .wrappedFactory(Executors.defaultThreadFactory())</span>
<span class="fc" id="L108">                    .namingPattern(getClass().getSimpleName() + &quot;(&quot; + unit.getName() + &quot;)@%d&quot;)</span>
<span class="fc" id="L109">                    .build());</span>

<span class="fc" id="L111">        unit.addConsumer(this);</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (Iterator&lt;Thermostat&gt; i = ts2damper.keySet().iterator(); i.hasNext(); ) {</span>

<span class="fc" id="L115">            Thermostat ts = i.next();</span>
<span class="fc" id="L116">            Damper d = ts2damper.get(ts);</span>

<span class="fc" id="L118">            put(ts, d);</span>

<span class="fc" id="L120">            ts.addConsumer(tsListener);</span>

<span class="fc" id="L122">            name2ts.put(ts.getName(), ts);</span>
<span class="fc" id="L123">        }</span>

<span class="fc" id="L125">    }</span>

    @Override
    public synchronized void put(Thermostat ts, Damper damper) {

<span class="fc" id="L130">        ts2damper.put(ts, damper);</span>
<span class="fc" id="L131">    }</span>

    @Override
    public synchronized void remove(Thermostat ts) {

<span class="nc" id="L136">        ts2damper.remove(ts);</span>
<span class="nc" id="L137">    }</span>

    public Future&lt;TransitionStatus&gt; stateChanged(Thermostat source, ThermostatSignal signal) {

<span class="fc" id="L141">        ThreadContext.push(&quot;signalChanged&quot;);</span>

        try {

<span class="fc" id="L145">            checkEnabled();</span>

<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            if (!ts2damper.containsKey(source)) {</span>
<span class="nc" id="L148">                throw new IllegalArgumentException(&quot;Don't know anything about &quot; + source);</span>
            }

<span class="fc" id="L151">            synchronized (this) {</span>
<span class="fc" id="L152">                ts2signal.put(source, signal);</span>
<span class="fc" id="L153">            }</span>

<span class="fc" id="L155">            logger.info(&quot;Demand: {}={}&quot;, source.getName(), signal.demand.sample);</span>
<span class="fc" id="L156">            logger.info(&quot;ts2signal.size()={}&quot;, ts2signal.size());</span>

<span class="fc" id="L158">            return sync();</span>

        } finally {
<span class="fc" id="L161">            ThreadContext.pop();</span>
        }
    }

    @Override
    public synchronized void consume(DataSample&lt;UnitSignal&gt; signal) {

<span class="fc" id="L168">        ThreadContext.push(&quot;consume&quot;);</span>

        try {

<span class="fc" id="L172">            checkEnabled();</span>

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (signal == null) {</span>
<span class="nc" id="L175">                throw new IllegalArgumentException(&quot;signal can't be null&quot;);</span>
            }

<span class="fc" id="L178">            logger.info(&quot;UnitSignal: {}&quot;, signal.sample);</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (this.hvacSignal == null) {</span>

<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                if (signal.sample.running) {</span>

                    // It would be realistic to assume it's been off, right?
<span class="fc" id="L185">                    logger.info(&quot;Turning ON&quot;);</span>

<span class="fc" id="L187">                    sync();</span>

                } else {

                    // Might've been killed last time, need to set the dampers straight
<span class="nc" id="L192">                    park(true);</span>
                }

<span class="pc bpc" id="L195" title="3 of 4 branches missed.">            } else if (!this.hvacSignal.sample.running &amp;&amp; signal.sample.running) {</span>

<span class="nc" id="L197">                logger.info(&quot;Turning ON&quot;);</span>

<span class="nc" id="L199">                sync();</span>

<span class="pc bpc" id="L201" title="2 of 4 branches missed.">            } else if (this.hvacSignal.sample.running &amp;&amp; !signal.sample.running) {</span>

<span class="nc" id="L203">                park(true);</span>

            } else {

                // No change except for recalculating the damper positions
<span class="fc" id="L208">                sync();</span>
            }


        } finally {
<span class="fc" id="L213">            this.hvacSignal = signal;</span>
<span class="fc" id="L214">            ThreadContext.pop();</span>
        }
<span class="fc" id="L216">    }</span>

    /**
     * Park the dampers.
     *
     * @return The {@link Future} that will be completed when all the dampers are parked.
     */
    private Future&lt;TransitionStatus&gt; park(boolean async) {

<span class="fc" id="L225">        ThreadContext.push(&quot;park/main&quot;);</span>

        // VT: NOTE: This object is bogus - the whole concept needs to be revisited; see #132

<span class="fc" id="L229">        TransitionStatus result = new TransitionStatus(hashCode());</span>

        try {

<span class="fc" id="L233">            Callable&lt;TransitionStatus&gt; c = () -&gt; {</span>

<span class="fc" id="L235">                Marker m = new Marker(&quot;park/callable&quot;);</span>
<span class="fc" id="L236">                ThreadContext.push(&quot;park/callable@&quot; + Integer.toHexString(hashCode()));</span>

                try {

<span class="fc" id="L240">                    logger.info(&quot;Turning OFF, async={}&quot;, async);</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">                    for (Damper d : ts2damper.values()) {</span>

                        // The underlying system is likely a singleton, no sense to spawn parallel threads

<span class="fc" id="L246">                        logger.debug(&quot;{}: parking&quot;,  d.getName());</span>

<span class="fc" id="L248">                        d.park().get();</span>

<span class="fc" id="L250">                        logger.info(&quot;{}: parked&quot;, d.getName());</span>
<span class="fc" id="L251">                    }</span>

<span class="fc" id="L253">                    result.complete(hashCode(), null);</span>

<span class="fc" id="L255">                    return result;</span>

                } finally {

<span class="fc" id="L259">                    m.close();</span>
<span class="fc" id="L260">                    ThreadContext.pop();</span>
<span class="fc" id="L261">                    ThreadContext.clearStack();</span>
                }
            };

<span class="fc" id="L265">            Future&lt;TransitionStatus&gt; done = executor.submit(c);</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (async) {</span>
<span class="fc" id="L268">                logger.debug(&quot;parking asynchronously&quot;);</span>
<span class="fc" id="L269">                return done;</span>
            }

<span class="fc" id="L272">            logger.debug(&quot;parking...&quot;);</span>
<span class="fc" id="L273">            done.get();</span>
<span class="fc" id="L274">            logger.info(&quot;parked&quot;);</span>

<span class="fc" id="L276">            return done;</span>

<span class="nc" id="L278">        } catch (InterruptedException| ExecutionException ex) {</span>

            // This is potentially expensive - may slug the HVAC if the dampers are
            // left closed while it is running, hence fatal level. Can't afford to disrupt
            // the parking sequence, though - we're likely shutting down.

<span class="nc" id="L284">            logger.fatal(&quot;failed to park dampers&quot;, ex);</span>

<span class="nc" id="L286">            result.complete(hashCode(), ex);</span>

<span class="nc" id="L288">            return CompletableFuture.completedFuture(result);</span>

        } finally {
<span class="fc" id="L291">            ThreadContext.pop();</span>
        }
    }

    /**
     * Set positions of dampers in the map.
     *
     * Normally, the positions will be set asynchronously. The only exception to this is
     * when {@code shuffle()} is called via {@link #park()} from {@link #powerOff()}.
     *
     * @param damperMap Key is the damper, value is the position to set.
     * @param async {@code true} if the positions are to be set asynchronously.
     */
    private Future&lt;TransitionStatus&gt; shuffle(Map&lt;Damper, Double&gt; damperMap, boolean async) {

<span class="fc" id="L306">        ThreadContext.push(&quot;shuffle&quot;);</span>

        try {

<span class="fc" id="L310">            Future&lt;TransitionStatus&gt; done = executor.submit(new Damper.MoveGroup(damperMap));</span>

<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (async) {</span>

<span class="fc" id="L314">                logger.debug(&quot;async call, bailing out&quot;);</span>
<span class="fc" id="L315">                return done;</span>
            }

            try {

<span class="nc" id="L320">                done.get();</span>
<span class="nc" id="L321">                return done;</span>

<span class="nc" id="L323">            } catch (InterruptedException | ExecutionException ex) {</span>

                // VT: FIXME: Oops... Really don't know what to do with this, will have to collect stats
                // before this can be reasonably handled

<span class="nc" id="L328">                throw new IllegalStateException(&quot;Unhandled exception&quot;, ex);</span>
            }

        } finally {

<span class="fc" id="L333">            lastMap.clear();</span>
<span class="fc" id="L334">            lastMap.putAll(damperMap);</span>

<span class="fc" id="L336">            ThreadContext.pop();</span>
        }
    }

    /**
     * Get the damper position map for instrumentation purposes.
     *
     * @return Damper positions as array of strings.
     */
    @JmxAttribute(description = &quot;Damper positions&quot;)
    public synchronized String[] getDamperMap() {

<span class="fc" id="L348">        String[] result = new String[lastMap.size()];</span>

<span class="fc" id="L350">        Map&lt;String, Double&gt; resultMap = new TreeMap&lt;&gt;();</span>

<span class="fc bfc" id="L352" title="All 2 branches covered.">        for (Iterator&lt;Damper&gt; i = lastMap.keySet().iterator(); i.hasNext(); ) {</span>

<span class="fc" id="L354">            Damper d = i.next();</span>
<span class="fc" id="L355">            Double position = lastMap.get(d);</span>

<span class="fc" id="L357">            resultMap.put(d.getName(), position);</span>
<span class="fc" id="L358">        }</span>

<span class="fc" id="L360">        int offset = 0;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        for (Iterator&lt;String&gt; i = resultMap.keySet().iterator(); i.hasNext(); ) {</span>

<span class="fc" id="L363">            String name = i.next();</span>
<span class="fc" id="L364">            Double position = resultMap.get(name);</span>

<span class="fc" id="L366">            result[offset++] = name + &quot;=&quot; + position;</span>
<span class="fc" id="L367">        }</span>

<span class="fc" id="L369">        return result;</span>
    }

    /**
     * Recalculate the damper state according to [possibly] changed internal state.
     */
    protected final Future&lt;TransitionStatus&gt; sync() {

        // VT: NOTE: This assumes compute() is stateless, ideally, it should stay that way.
        // If there is ever a need to make it stateful, compute() should be called outside
        // of the fork and the map passed to shuffle) within.

<span class="pc bpc" id="L381" title="1 of 4 branches missed.">        if (this.hvacSignal != null &amp;&amp; this.hvacSignal.sample.running) {</span>

<span class="fc" id="L383">            return shuffle(compute(ts2damper, ts2signal), true);</span>

        } else {

<span class="fc" id="L387">            return park(true);</span>
        }
    }

    private void checkEnabled() {
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L393">            throw new IllegalStateException(&quot;powerOff() was called already&quot;);</span>
        }
<span class="fc" id="L395">    }</span>

    @Override
    public final Future&lt;TransitionStatus&gt; powerOff() {

<span class="fc" id="L400">        ThreadContext.push(&quot;powerOff&quot;);</span>

        try {

<span class="fc" id="L404">            enabled = false;</span>
<span class="fc" id="L405">            logger.warn(&quot;Powering off&quot;);</span>

            // This is a synchronous operation
<span class="fc" id="L408">            Future&lt;TransitionStatus&gt; done = park(false);</span>

<span class="fc" id="L410">            logger.info(&quot;shut down.&quot;);</span>

<span class="fc" id="L412">            return done;</span>

        } finally {
<span class="fc" id="L415">            ThreadContext.pop();</span>
        }
    }

    /**
     * Compute damper positions based on known data.
     *
     * This method is package private to facilitate testing.
     *
     * @param ts2damper Thermostat to damper mapping.
     * @param ts2signal Thermostat to signal mapping.
     */
    abstract Map&lt;Damper, Double&gt; compute(Map&lt;Thermostat, Damper&gt; ts2damper, Map&lt;Thermostat, ThermostatSignal&gt; ts2signal);

<span class="fc" id="L429">    private class ThermostatListener implements DataSink&lt;ThermostatSignal&gt; {</span>

        @Override
        public void consume(DataSample&lt;ThermostatSignal&gt; signal) {

<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (signal == null) {</span>
<span class="nc" id="L435">                throw new IllegalArgumentException(&quot;signal can't be null&quot;);</span>
            }

<span class="nc" id="L438">            Thermostat source = name2ts.get(signal.sourceName);</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (source == null) {</span>
<span class="nc" id="L441">                throw new IllegalArgumentException(&quot;Don't know anything about '&quot; + signal.sourceName + &quot;'&quot;);</span>
            }

<span class="nc" id="L444">            stateChanged(source, signal.sample);</span>
<span class="nc" id="L445">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>