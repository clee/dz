<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MemoryBankEEPROMstatus.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OWAPI 1.00 refactored for DIY Zoning</a> &gt; <a href="index.source.html" class="el_package">com.dalsemi.onewire.container</a> &gt; <span class="el_source">MemoryBankEEPROMstatus.java</span></div><h1>MemoryBankEEPROMstatus.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------
 * Copyright (C) 1999,2000 Dallas Semiconductor Corporation, All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL DALLAS SEMICONDUCTOR BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Dallas Semiconductor
 * shall not be used except as stated in the Dallas Semiconductor
 * Branding Policy.
 *---------------------------------------------------------------------------
 */

package com.dalsemi.onewire.container;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.dalsemi.onewire.OneWireException;
import com.dalsemi.onewire.adapter.DSPortAdapter;
import com.dalsemi.onewire.adapter.OneWireIOException;
import com.dalsemi.onewire.utils.CRC16;

/**
 * Memory bank class for the EEPROM section of iButtons and 1-Wire devices on
 * the DS2408.
 * 
 * @version 0.00, 28 Aug 2000
 * @author DS
 * @author Stability enhancements &amp;copy; &lt;a href=&quot;mailto:vt@freehold.crocodile.org&quot;&gt; Vadim Tkachenko&lt;/a&gt; 2001-2018
 */
class MemoryBankEEPROMstatus implements MemoryBank {
    
<span class="nc" id="L48">    protected final Logger logger = LogManager.getLogger(getClass()); </span>

    // --------
    // -------- Static Final Variables
    // --------

    /**
     * Read Memory Command
     */
    public static final byte READ_MEMORY_COMMAND = (byte) 0xF0;

    /**
     * Write Scratchpad Command
     */
    public static final byte WRITE_SCRATCHPAD_COMMAND = (byte) 0x0F;

    /**
     * Read Scratchpad Command
     */
    public static final byte READ_SCRATCHPAD_COMMAND = (byte) 0xAA;

    /**
     * Copy Scratchpad Command
     */
    public static final byte COPY_SCRATCHPAD_COMMAND = (byte) 0x55;

    /**
     * Channel acces write to change the property of the channel
     */
    public static final byte CHANNEL_ACCESS_WRITE = (byte) 0x5A;

    // --------
    // -------- Variables
    // --------

    /**
     * Reference to the OneWireContainer this bank resides on.
     */
    protected OneWireContainer ib;

    /**
     * block of 0xFF's used for faster read pre-fill of 1-Wire blocks
     */
    protected byte[] ffBlock;

    /**
     * Flag to indicate that speed needs to be set
     */
    protected boolean doSetSpeed;

    // --------
    // -------- Protected Variables for MemoryBank implementation
    // --------

    /**
     * Size of memory bank in bytes
     */
    protected int size;

    /**
     * Memory bank descriptions
     */
    protected String bankDescription;

    /**
     * Memory bank usage flags
     */
    protected boolean generalPurposeMemory;

    /**
     * Flag if memory bank is read/write
     */
    protected boolean readWrite;

    /**
     * Flag if memory bank is write once (EPROM)
     */
    protected boolean writeOnce;

    /**
     * Flag if memory bank is read only
     */
    protected boolean readOnly;

    /**
     * Flag if memory bank is non volatile (will not erase when power removed)
     */
    protected boolean nonVolatile;

    /**
     * Flag if memory bank needs program Pulse to write
     */
    protected boolean programPulse;

    /**
     * Flag if memory bank needs power delivery to write
     */
    protected boolean powerDelivery;

    /**
     * Starting physical address in memory bank. Needed for different types of
     * memory in the same logical memory bank. This can be used to seperate them
     * into two virtual memory banks. Example: DS2406 status page has mixed
     * EPROM and Volatile RAM.
     */
    protected int startPhysicalAddress;

    /**
     * Flag if read back verification is enabled in 'write()'.
     */
    protected boolean writeVerification;

    // --------
    // -------- Protected Variables for PagedMemoryBank implementation
    // --------

    /**
     * Number of pages in memory bank
     */
    protected int numberPages;

    /**
     * page length in memory bank
     */
    protected int pageLength;

    /**
     * Max data length in page packet in memory bank
     */
    protected int maxPacketDataLength;

    /**
     * Flag if memory bank has page auto-CRC generation
     */
    protected boolean pageAutoCRC;

    // --------
    // -------- Constructor
    // --------

    /**
     * Memory bank contstuctor. Requires reference to the OneWireContainer this
     * memory bank resides on. Requires reference to memory banks used in OTP
     * operations.
     */
<span class="nc" id="L193">    public MemoryBankEEPROMstatus(OneWireContainer ibutton) {</span>

        // keep reference to ibutton where memory bank is
<span class="nc" id="L196">        ib = ibutton;</span>

        // initialize attributes of this memory bank - DEFAULT: Main memory
        // DS1985 w/o lock stuff
<span class="nc" id="L200">        generalPurposeMemory = false;</span>
<span class="nc" id="L201">        bankDescription = &quot;Main Memory&quot;;</span>
<span class="nc" id="L202">        numberPages = 1;</span>
<span class="nc" id="L203">        readWrite = false;</span>
<span class="nc" id="L204">        writeOnce = false;</span>
<span class="nc" id="L205">        readOnly = false;</span>
<span class="nc" id="L206">        nonVolatile = true;</span>
<span class="nc" id="L207">        pageAutoCRC = true;</span>
<span class="nc" id="L208">        programPulse = false;</span>
<span class="nc" id="L209">        powerDelivery = false;</span>
<span class="nc" id="L210">        writeVerification = false;</span>
<span class="nc" id="L211">        startPhysicalAddress = 0;</span>
<span class="nc" id="L212">        doSetSpeed = true;</span>

        // create the ffblock (used for faster 0xFF fills)
<span class="nc" id="L215">        ffBlock = new byte[20];</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = 0; i &lt; 20; i++) {</span>
<span class="nc" id="L218">            ffBlock[i] = (byte) 0xFF;</span>
        }
<span class="nc" id="L220">    }</span>

    // --------
    // -------- MemoryBank query methods
    // --------

    /**
     * Query to see get a string description of the current memory bank.
     * 
     * @return String containing the memory bank description
     */
    @Override
    public String getBankDescription() {
<span class="nc" id="L233">        return bankDescription;</span>
    }

    /**
     * Query to see if the current memory bank is general purpose user memory.
     * If it is NOT then it is Memory-Mapped and writing values to this memory
     * will affect the behavior of the 1-Wire device.
     * 
     * @return 'true' if current memory bank is general purpose
     */
    @Override
    public boolean isGeneralPurposeMemory() {
<span class="nc" id="L245">        return generalPurposeMemory;</span>
    }

    /**
     * Query to see if current memory bank is read/write.
     * 
     * @return 'true' if current memory bank is read/write
     */
    @Override
    public boolean isReadWrite() {
<span class="nc" id="L255">        return readWrite;</span>
    }

    /**
     * Query to see if current memory bank is write write once such as with
     * EPROM technology.
     * 
     * @return 'true' if current memory bank can only be written once
     */
    @Override
    public boolean isWriteOnce() {
<span class="nc" id="L266">        return writeOnce;</span>
    }

    /**
     * Query to see if current memory bank is read only.
     * 
     * @return 'true' if current memory bank can only be read
     */
    @Override
    public boolean isReadOnly() {
<span class="nc" id="L276">        return readOnly;</span>
    }

    /**
     * Query to see if current memory bank non-volatile. Memory is non-volatile
     * if it retains its contents even when removed from the 1-Wire network.
     * 
     * @return 'true' if current memory bank non volatile.
     */
    @Override
    public boolean isNonVolatile() {
<span class="nc" id="L287">        return nonVolatile;</span>
    }

    /**
     * Query to see if current memory bank pages need the adapter to have a
     * 'ProgramPulse' in order to write to the memory.
     * 
     * @return 'true' if writing to the current memory bank pages requires a
     *         'ProgramPulse'.
     */
    @Override
    public boolean needsProgramPulse() {
<span class="nc" id="L299">        return programPulse;</span>
    }

    /**
     * Query to see if current memory bank pages need the adapter to have a
     * 'PowerDelivery' feature in order to write to the memory.
     * 
     * @return 'true' if writing to the current memory bank pages requires
     *         'PowerDelivery'.
     */
    @Override
    public boolean needsPowerDelivery() {
<span class="nc" id="L311">        return powerDelivery;</span>
    }

    /**
     * Query to get the starting physical address of this bank. Physical banks
     * are sometimes sub-divided into logical banks due to changes in
     * attributes.
     * 
     * @return physical starting address of this logical bank.
     */
    @Override
    public int getStartPhysicalAddress() {
<span class="nc" id="L323">        return startPhysicalAddress;</span>
    }

    /**
     * Query to get the memory bank size in bytes.
     * 
     * @return memory bank size in bytes.
     */
    @Override
    public int getSize() {
<span class="nc" id="L333">        return size;</span>
    }

    // --------
    // -------- PagedMemoryBank query methods
    // --------

    /**
     * Query to get the number of pages in current memory bank.
     * 
     * @return number of pages in current memory bank
     */
    public int getNumberPages() {
<span class="nc" id="L346">        return numberPages;</span>
    }

    /**
     * Query to get page length in bytes in current memory bank.
     * 
     * @return page length in bytes in current memory bank
     */
    public int getPageLength() {
<span class="nc" id="L355">        return pageLength;</span>
    }

    /**
     * Query to get Maximum data page length in bytes for a packet read or
     * written in the current memory bank. See the 'ReadPagePacket()' and
     * 'WritePagePacket()' methods. This method is only usefull if the current
     * memory bank is general purpose memory.
     * 
     * @return max packet page length in bytes in current memory bank
     */
    public int getMaxPacketDataLength() {
<span class="nc" id="L367">        return maxPacketDataLength;</span>
    }

    /**
     * Query to see if current memory bank pages can be read with the contents
     * being verified by a device generated CRC. This is used to see if the
     * 'ReadPageCRC()' can be used.
     * 
     * @return 'true' if current memory bank can be read with self generated
     *         CRC.
     */
    public boolean hasPageAutoCRC() {
<span class="nc" id="L379">        return pageAutoCRC;</span>
    }

    /**
     * Checks to see if this memory bank's pages deliver extra information
     * outside of the normal data space, when read. Examples of this may be a
     * redirection byte, counter, tamper protection bytes, or SHA-1 result. If
     * this method returns true then the methods with an 'extraInfo' parameter
     * can be used: {@link #readPage(int,boolean,byte[],int,byte[]) readPage},
     * {@link #readPageCRC(int,boolean,byte[],int,byte[]) readPageCRC}, and
     * {@link #readPagePacket(int,boolean,byte[],int,byte[]) readPagePacket}.
     * 
     * @return &lt;CODE&gt; true &lt;/CODE&gt; if reading the this memory bank's pages
     *         provides extra information
     * 
     * @see #readPage(int,boolean,byte[],int,byte[]) readPage(extra)
     * @see #readPageCRC(int,boolean,byte[],int,byte[]) readPageCRC(extra)
     * @see #readPagePacket(int,boolean,byte[],int,byte[]) readPagePacket(extra)
     * @since 1-Wire API 0.01
     */
    public boolean hasExtraInfo() {
<span class="nc" id="L400">        return false;</span>
    }

    /**
     * Query to get the length in bytes of extra information that is read when
     * read a page in the current memory bank. See 'hasExtraInfo()'.
     * 
     * @return number of bytes in Extra Information read when reading pages in
     *         the current memory bank.
     */
    public int getExtraInfoLength() {
<span class="nc" id="L411">        return 0;</span>
    }

    /**
     * Query to get a string description of what is contained in the Extra
     * Informationed return when reading pages in the current memory bank. See
     * 'hasExtraInfo()'.
     * 
     * @return string describing extra information.
     */
    public String getExtraInfoDescription() {
<span class="nc" id="L422">        return null;</span>
    }

    /**
     * Set the write verification for the 'write()' method.
     * 
     * @param doReadVerf
     *            true (default) verify write in 'write' false, don't verify
     *            write (used on Write-Once bit manipulation)
     */
    public void setWriteVerification(boolean doReadVerf) {
<span class="nc" id="L433">        writeVerification = doReadVerf;</span>
<span class="nc" id="L434">    }</span>

    // --------
    // -------- MemoryBank I/O methods
    // --------

    /**
     * Read memory in the current bank with no CRC checking (device or data).
     * The resulting data from this API may or may not be what is on the 1-Wire
     * device. It is recommends that the data contain some kind of checking
     * (CRC) like in the readPagePacket() method or have the 1-Wire device
     * provide the CRC as in readPageCRC(). readPageCRC() however is not
     * supported on all memory types, see 'hasPageAutoCRC()'. If neither is an
     * option then this method could be called more then once to at least verify
     * that the same thing is read consistantly.
     * 
     * @param startAddr
     *            starting physical address
     * @param readContinue
     *            if 'true' then device read is continued without re-selecting.
     *            This can only be used if the new read() continious where the
     *            last one led off and it is inside a
     *            'beginExclusive/endExclusive' block.
     * @param readBuf
     *            byte array to place read data into
     * @param offset
     *            offset into readBuf to place data
     * @param len
     *            length in bytes to read
     * 
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void read(int startAddr, boolean readContinue, byte[] readBuf,
            int offset, int len) throws OneWireIOException, OneWireException {
<span class="nc" id="L470">        byte[] buff = new byte[20];</span>
<span class="nc" id="L471">        int addr = startPhysicalAddress + startAddr;</span>

<span class="nc" id="L473">        System.arraycopy(ffBlock, 0, buff, 0, 20);</span>

        // check if read exceeds memory
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if ((startAddr + len) &gt; size)</span>
<span class="nc" id="L477">            throw new OneWireException(&quot;Read exceeds memory bank end&quot;);</span>

        // attempt to put device at max desired speed
        // attempt to put device at max desired speed
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (!readContinue) {</span>
<span class="nc" id="L482">            checkSpeed();</span>

            // select the device
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (ib.adapter.select(ib.address)) {</span>
<span class="nc" id="L486">                buff[0] = READ_MEMORY_COMMAND;</span>

                // address 1
<span class="nc" id="L489">                buff[1] = (byte) (addr &amp; 0xFF);</span>
                // address 2
<span class="nc" id="L491">                buff[2] = (byte) (((addr &amp; 0xFFFF) &gt;&gt;&gt; 8) &amp; 0xFF);</span>

<span class="nc" id="L493">                ib.adapter.dataBlock(buff, 0, len + 3);</span>

                // extract the data
<span class="nc" id="L496">                System.arraycopy(buff, 3, readBuf, offset, len);</span>
            } else
<span class="nc" id="L498">                throw new OneWireIOException(&quot;Device select failed&quot;);</span>
        } else {
<span class="nc" id="L500">            ib.adapter.dataBlock(buff, 0, len);</span>

            // extract the data
<span class="nc" id="L503">            System.arraycopy(buff, 0, readBuf, offset, len);</span>
        }
<span class="nc" id="L505">    }</span>

    /**
     * Write memory in the current bank. It is recommended that when writing
     * data that some structure in the data is created to provide error free
     * reading back with read(). Or the method 'writePagePacket()' could be used
     * which automatically wraps the data in a length and CRC.
     * 
     * When using on Write-Once devices care must be taken to write into into
     * empty space. If write() is used to write over an unlocked page on a
     * Write-Once device it will fail. If write verification is turned off with
     * the method 'setWriteVerification(false)' then the result will be an 'AND'
     * of the existing data and the new data.
     * 
     * @param startAddr
     *            starting address
     * @param writeBuf
     *            byte array containing data to write
     * @param offset
     *            offset into writeBuf to get data
     * @param len
     *            length in bytes to write
     * 
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void write(int startAddr, byte[] writeBuf, int offset, int len)
            throws OneWireIOException, OneWireException {
        int i;
<span class="nc" id="L535">        byte[] es_data = new byte[3];</span>
<span class="nc" id="L536">        byte[] scratchpad = new byte[8];</span>

        // return if nothing to do
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (len == 0)</span>
<span class="nc" id="L540">            return;</span>

        // attempt to put device at speed
<span class="nc" id="L543">        checkSpeed();</span>

        // check if write exceeds memory
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if ((startAddr + len) &gt; size)</span>
<span class="nc" id="L547">            throw new OneWireException(&quot;Write exceeds memory bank end&quot;);</span>

        // check if trying to write read only bank
<span class="nc bnc" id="L550" title="All 6 branches missed.">        if (isReadOnly()</span>
                &amp;&amp; (((startPhysicalAddress + startAddr) != 137) &amp;&amp; (len != 1)))
<span class="nc" id="L552">            throw new OneWireException(&quot;Trying to write read-only memory bank&quot;);</span>

<span class="nc bnc" id="L554" title="All 4 branches missed.">        if (((startPhysicalAddress + startAddr) == 137) &amp;&amp; (len == 1)) {</span>
<span class="nc" id="L555">            ib.adapter.select(ib.address);</span>

<span class="nc" id="L557">            byte[] buffer = new byte[5];</span>

<span class="nc" id="L559">            buffer[0] = CHANNEL_ACCESS_WRITE;</span>
<span class="nc" id="L560">            buffer[1] = writeBuf[offset];</span>
<span class="nc" id="L561">            buffer[2] = (byte) ~writeBuf[offset];</span>
<span class="nc" id="L562">            System.arraycopy(ffBlock, 0, buffer, 3, 2);</span>

<span class="nc" id="L564">            ib.adapter.dataBlock(buffer, 0, 5);</span>

<span class="nc bnc" id="L566" title="All 2 branches missed.">            if (buffer[3] != (byte) 0x00AA) {</span>
<span class="nc" id="L567">                throw new OneWireIOException(</span>
                        &quot;Failure to change DS2408 latch state.&quot;);
            }
<span class="nc bnc" id="L570" title="All 4 branches missed.">        } else if (((startPhysicalAddress + startAddr) &gt; 138)</span>
                &amp;&amp; ((startPhysicalAddress + startAddr + len) &lt; 143)) {
<span class="nc" id="L572">            ib.adapter.select(ib.address);</span>

<span class="nc" id="L574">            byte[] buffer = new byte[6];</span>

<span class="nc" id="L576">            buffer[0] = (byte) 0xCC;</span>
<span class="nc" id="L577">            buffer[1] = (byte) ((startAddr + startPhysicalAddress) &amp; 0xFF);</span>
<span class="nc" id="L578">            buffer[2] = (byte) ((((startAddr + startPhysicalAddress) &amp; 0xFFFF) &gt;&gt;&gt; 8) &amp; 0xFF);</span>

<span class="nc" id="L580">            System.arraycopy(writeBuf, offset, buffer, 3, len);</span>

<span class="nc" id="L582">            ib.adapter.dataBlock(buffer, 0, len + 3);</span>
<span class="nc bnc" id="L583" title="All 4 branches missed.">        } else if (((startPhysicalAddress + startAddr) &gt; 127)</span>
                &amp;&amp; ((startPhysicalAddress + startAddr + len) &lt; 130)) {
<span class="nc" id="L585">            byte[] buffer = new byte[8];</span>
<span class="nc" id="L586">            int addr = 128;</span>
<span class="nc" id="L587">            byte[] buff = new byte[11];</span>

<span class="nc" id="L589">            System.arraycopy(ffBlock, 0, buff, 0, 11);</span>

<span class="nc" id="L591">            ib.adapter.select(ib.address);</span>

<span class="nc" id="L593">            buff[0] = READ_MEMORY_COMMAND;</span>

            // address 1
<span class="nc" id="L596">            buff[1] = (byte) (addr &amp; 0xFF);</span>
            // address 2
<span class="nc" id="L598">            buff[2] = (byte) (((addr &amp; 0xFFFF) &gt;&gt;&gt; 8) &amp; 0xFF);</span>

<span class="nc" id="L600">            ib.adapter.dataBlock(buff, 0, 11);</span>

            // extract the data
<span class="nc" id="L603">            System.arraycopy(buff, 3, buffer, 0, 8);</span>

<span class="nc" id="L605">            System.arraycopy(writeBuf, offset, buffer, 0, len);</span>

            // write the page of data to scratchpad
<span class="nc bnc" id="L608" title="All 2 branches missed.">            if (!writeScratchpad(startPhysicalAddress + startAddr, buffer, 0, 8))</span>
<span class="nc" id="L609">                throw new OneWireIOException(&quot;Invalid CRC16 in write&quot;);</span>

<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (!readScratchpad(scratchpad, 0, 8, es_data))</span>
<span class="nc" id="L612">                throw new OneWireIOException(</span>
                        &quot;Read scratchpad was not successful.&quot;);

<span class="nc bnc" id="L615" title="All 2 branches missed.">            if ((es_data[2] &amp; 0x20) == 0x20) {</span>
<span class="nc" id="L616">                throw new OneWireIOException(</span>
                        &quot;The write scratchpad command was not completed.&quot;);
            } else {
<span class="nc bnc" id="L619" title="All 2 branches missed.">                for (i = 0; i &lt; 8; i++)</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                    if (scratchpad[i] != buffer[i]) {</span>
<span class="nc" id="L621">                        throw new OneWireIOException(</span>
                                &quot;The read back of the data in the scratch pad did &quot;
                                        + &quot;not match.&quot;);
                    }
            }

            // Copy data from scratchpad into memory
<span class="nc" id="L628">            copyScratchpad(es_data);</span>
<span class="nc" id="L629">        } else</span>
<span class="nc" id="L630">            throw new OneWireIOException(&quot;Trying to write read-only memory.&quot;);</span>
<span class="nc" id="L631">    }</span>

    // --------
    // -------- checkSpeed methods
    // --------

    /**
     * Check the device speed if has not been done before or if an error was
     * detected.
     * 
     * @throws OneWireIOException
     * @throws OneWireException
     */
    public void checkSpeed() throws OneWireIOException, OneWireException {
<span class="nc" id="L645">        synchronized (this) {</span>

            // only check the speed
<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (doSetSpeed) {</span>

                // attempt to set the correct speed and verify device present
<span class="nc" id="L651">                ib.doSpeed();</span>

                // no execptions so clear flag
<span class="nc" id="L654">                doSetSpeed = false;</span>
            }
<span class="nc" id="L656">        }</span>
<span class="nc" id="L657">    }</span>

    /**
     * Set the flag to indicate the next 'checkSpeed()' will force a speed set
     * and verify 'doSpeed()'.
     */
    public synchronized void forceVerify() {
<span class="nc" id="L664">        doSetSpeed = true;</span>
<span class="nc" id="L665">    }</span>

    /**
     * Write to the Scratch Pad, which is a max of 8 bytes... Note that if less
     * than 8 bytes are written, the ending offset will still report that a full
     * eight bytes are on the buffer. This means that all 8 bytes of the data in
     * the scratchpad will be copied, not just the bytes user wrote into it.
     * 
     * @param addr
     *            the address to write the data to
     * @param out_buf
     *            byte array to write into scratch pad
     * @param offset
     *            offset into out_buf to write the data
     * @param len
     *            length of the write data
     * 
     * @throws OneWireIOException
     * @throws OneWireException
     */
    public boolean writeScratchpad(int addr, byte[] out_buf, int offset, int len)
            throws OneWireIOException, OneWireException {
<span class="nc" id="L687">        byte[] send_block = new byte[14];</span>

        // protect send buffer
        // since the scratchpad is only eight bytes, there is no reason to write
        // more than eight bytes.. and we can optimize our send buffer's size.
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (len &gt; 8)</span>
<span class="nc" id="L693">            len = 8;</span>

        // access the device
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (ib.adapter.select(ib.getAddress())) {</span>
<span class="nc" id="L697">            int cnt = 0;</span>
            // set data block up
            // start by sending the write scratchpad command
<span class="nc" id="L700">            send_block[cnt++] = WRITE_SCRATCHPAD_COMMAND;</span>
            // followed by the target address
<span class="nc" id="L702">            send_block[cnt++] = (byte) (addr &amp; 0x00FF);</span>
<span class="nc" id="L703">            send_block[cnt++] = (byte) (((addr &amp; 0x00FFFF) &gt;&gt;&gt; 8) &amp; 0x00FF);</span>

            // followed by the data to write to the scratchpad
<span class="nc" id="L706">            System.arraycopy(out_buf, offset, send_block, 3, len);</span>
<span class="nc" id="L707">            cnt += len;</span>

            // followed by two bytes for reading CRC16 value
<span class="nc" id="L710">            send_block[cnt++] = (byte) 0x00FF;</span>
<span class="nc" id="L711">            send_block[cnt++] = (byte) 0x00FF;</span>

            // send the data
<span class="nc" id="L714">            ib.adapter.dataBlock(send_block, 0, cnt);</span>

            // verify the CRC is correct
            // if (CRC16.compute(send_block, 0, cnt) != 0x0000B001)
            // throw new
            // OneWireIOException(&quot;Invalid CRC16 in Writing Scratch Pad&quot;);
<span class="nc" id="L720">        } else {</span>
<span class="nc" id="L721">            throw new OneWireIOException(&quot;Device select failed.&quot;);</span>
        }

<span class="nc" id="L724">        return true;</span>
    }

    /**
     * Copy all 8 bytes of the Sratch Pad to a certain address in memory.
     * 
     * @param addr
     *            the address to copy the data to
     * @param auth
     *            byte[] containing write authorization
     * 
     * @throws OneWireIOException
     * @throws OneWireException
     */
    public synchronized void copyScratchpad(byte[] es_data)
            throws OneWireIOException, OneWireException {
<span class="nc" id="L740">        byte[] send_block = new byte[4];</span>

        // access the device
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (ib.adapter.select(ib.getAddress())) {</span>
            // ending address with data status
<span class="nc" id="L745">            send_block[3] = es_data[2];// ES;</span>

            // address 2
<span class="nc" id="L748">            send_block[2] = es_data[1];// TA2</span>

            // address 1
<span class="nc" id="L751">            send_block[1] = es_data[0];// TA1;</span>

            // Copy command
<span class="nc" id="L754">            send_block[0] = COPY_SCRATCHPAD_COMMAND;</span>

            // send copy scratchpad command
<span class="nc" id="L757">            ib.adapter.dataBlock(send_block, 0, 3);</span>

            // provide strong pull-up for copy
<span class="nc" id="L760">            ib.adapter.setPowerDuration(DSPortAdapter.DELIVERY_INFINITE);</span>
<span class="nc" id="L761">            ib.adapter.startPowerDelivery(DSPortAdapter.CONDITION_AFTER_BYTE);</span>
<span class="nc" id="L762">            ib.adapter.putByte(send_block[3]);</span>

            // pause before checking result
            try {
<span class="nc" id="L766">                Thread.sleep(12);</span>
<span class="nc" id="L767">            } catch (InterruptedException ex) {</span>
<span class="nc" id="L768">                logger.debug(&quot;Interrupted&quot;, ex);</span>
<span class="nc" id="L769">            }</span>

<span class="nc" id="L771">            ib.adapter.setPowerNormal();</span>

            // get result
<span class="nc" id="L774">            byte test = (byte) ib.adapter.getByte();</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (test == (byte) 0x00FF) {</span>
<span class="nc" id="L777">                throw new OneWireIOException(</span>
                        &quot;The scratchpad did not get copied to memory.&quot;);
            }
<span class="nc" id="L780">        } else {</span>
<span class="nc" id="L781">            throw new OneWireIOException(&quot;Device select failed.&quot;);</span>
        }
<span class="nc" id="L783">    }</span>

    /**
     * Read from the Scratch Pad, which is a max of 8 bytes.
     * 
     * @param readBuf
     *            byte array to place read data into length of array is always
     *            pageLength.
     * @param offset
     *            offset into readBuf to pug data
     * @param len
     *            length in bytes to read
     * @param extraInfo
     *            byte array to put extra info read into (TA1, TA2, e/s byte)
     *            Can be 'null' if extra info is not needed.
     * 
     * @throws OneWireIOException
     * @throws OneWireException
     */
    public boolean readScratchpad(byte[] readBuf, int offset, int len,
            byte[] es_data) throws OneWireIOException, OneWireException {
        // select the device
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (!ib.adapter.select(ib.address)) {</span>
<span class="nc" id="L806">            forceVerify();</span>
<span class="nc" id="L807">            throw new OneWireIOException(&quot;Device select failed&quot;);</span>
        }

        // build first block
<span class="nc" id="L811">        byte[] raw_buf = new byte[14];</span>
<span class="nc" id="L812">        raw_buf[0] = READ_SCRATCHPAD_COMMAND;</span>
<span class="nc" id="L813">        System.arraycopy(ffBlock, 0, raw_buf, 1, 13);</span>

        // do data block for TA1, TA2, and E/S
        // followed by 8 bytes of data and 2 bytes of crc
<span class="nc" id="L817">        ib.adapter.dataBlock(raw_buf, 0, 14);</span>

        // verify CRC16 is correct
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (CRC16.compute(raw_buf, 0, 14) == 0x0000B001) {</span>
            // optionally extract the extra info
<span class="nc bnc" id="L822" title="All 2 branches missed.">            if (es_data != null)</span>
<span class="nc" id="L823">                System.arraycopy(raw_buf, 1, es_data, 0, 3);</span>

<span class="nc" id="L825">            System.arraycopy(raw_buf, 4, readBuf, offset, len);</span>
            // success
<span class="nc" id="L827">            return true;</span>
        } else {
<span class="nc" id="L829">            throw new OneWireException(&quot;Error due to CRC.&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>