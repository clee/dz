<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OneWireContainer1F.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OWAPI 1.00 refactored for DIY Zoning</a> &gt; <a href="index.source.html" class="el_package">com.dalsemi.onewire.container</a> &gt; <span class="el_source">OneWireContainer1F.java</span></div><h1>OneWireContainer1F.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------
 * Copyright (C) 1999,2000 Dallas Semiconductor Corporation, All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL DALLAS SEMICONDUCTOR BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Dallas Semiconductor
 * shall not be used except as stated in the Dallas Semiconductor
 * Branding Policy.
 *---------------------------------------------------------------------------
 */

package com.dalsemi.onewire.container;

import com.dalsemi.onewire.OneWireException;
import com.dalsemi.onewire.adapter.DSPortAdapter;
import com.dalsemi.onewire.adapter.OneWireIOException;
import com.dalsemi.onewire.utils.Bit;

/**
 * &lt;P&gt;
 * 1-Wire&amp;#174 container for 1-Wire(MicroLAN) Coupler, DS2409. This container
 * encapsulates the functionality of the 1-Wire family type &lt;B&gt;1F&lt;/B&gt; (hex).
 * &lt;/P&gt;
 * 
 * &lt;H3&gt;Features&lt;/H3&gt;
 * &lt;UL&gt;
 * &lt;li&gt;Low impedance coupler to create large common-ground, multi-level MicroLAN
 * networks
 * &lt;li&gt;Keeps inactive branches pulled high to 5V
 * &lt;li&gt;Simplifies network topology analysis by logically decoupling devices on
 * active network segments
 * &lt;li&gt;Conditional search for fast event signaling
 * &lt;li&gt;Auxiliary 1-Wire TM line to connect a memory chip or to be used as
 * digital input
 * &lt;li&gt;Programmable, general purpose open drain control output
 * &lt;li&gt;Operating temperature range from -40&amp;#176C to +85&amp;#176C
 * &lt;li&gt;Compact, low cost 6-pin TSOC surface mount package
 * &lt;/UL&gt;
 * 
 * &lt;P&gt;
 * Setting the latch on the DS2409 to 'on' (see
 * {@link #setLatchState(int,boolean,boolean,byte[]) seLatchState}) connects the
 * channel [Main(0) or Auxillary(1)] to the 1-Wire data line. Note that this is
 * the opposite of the {@link com.dalsemi.onewire.container.OneWireContainer12
 * DS2406} and {@link com.dalsemi.onewire.container.OneWireContainer05 DS2405}
 * which connect thier I/O lines to ground.
 * &lt;H3&gt;Usage&lt;/H3&gt;
 * 
 * &lt;DL&gt;
 * &lt;DD&gt;See the usage example in
 * {@link com.dalsemi.onewire.container.SwitchContainer SwitchContainer} for
 * basic switch operations.
 * &lt;/DL&gt;
 * 
 * &lt;H3&gt;DataSheet&lt;/H3&gt;
 * &lt;DL&gt;
 * &lt;DD&gt;&lt;A HREF=&quot;http://pdfserv.maxim-ic.com/arpdf/DS2409.pdf&quot;&gt;
 * http://pdfserv.maxim-ic.com/arpdf/DS2409.pdf&lt;/A&gt;
 * &lt;/DL&gt;
 * 
 * @see com.dalsemi.onewire.container.OneWireSensor
 * @see com.dalsemi.onewire.container.SwitchContainer
 * @see com.dalsemi.onewire.container.OneWireContainer05
 * @see com.dalsemi.onewire.container.OneWireContainer12
 * 
 * @version 0.00, 13 Sept 2000
 * @author DSS
 * @author Stability enhancements &amp;copy; &lt;a
 *         href=&quot;mailto:vt@freehold.crocodile.org&quot;&gt; Vadim Tkachenko&lt;/a&gt;
 *         2001-2009
 */
public class OneWireContainer1F extends OneWireContainer implements
        SwitchContainer {

    // --------
    // -------- Static Final Variables
    // --------

    /** Offset of BITMAP in array returned from read state. */
    protected static final int BITMAP_OFFSET = 3;

    /** Offset of Status in array returned from read state. */
    protected static final int STATUS_OFFSET = 0;

    /** Offset of Main channel flag in array returned from read state. */
    protected static final int MAIN_OFFSET = 1;

    /** Offset of Main channel flag in array returned from read state. */
    protected static final int AUX_OFFSET = 2;

    /** Channel flag to indicate turn off. */
    protected static final int SWITCH_OFF = 0;

    /** Channel flag to indicate turn on. */
    protected static final int SWITCH_ON = 1;

    /** Channel flag to indicate smart on. */
    protected static final int SWITCH_SMART = 2;

    /** Read Write Status register commmand. */
    protected static final byte READ_WRITE_STATUS_COMMAND = (byte) 0x5A;

    /** All lines off command. */
    protected static final byte ALL_LINES_OFF_COMMAND = (byte) 0x66;

    /** Discharge command. */
    protected static final byte DISCHARGE_COMMAND = (byte) 0x99;

    /** Direct on main command. */
    protected static final byte DIRECT_ON_MAIN_COMMAND = (byte) 0xA5;

    /** Smart on main command. */
    protected static final byte SMART_ON_MAIN_COMMAND = (byte) 0xCC;

    /** Smart on aux command. */
    protected static final byte SMART_ON_AUX_COMMAND = (byte) 0x33;

    /** Main Channel number. */
    public static final int CHANNEL_MAIN = 0;

    /** Aux Channel number. */
    public static final int CHANNEL_AUX = 1;

    // --------
    // -------- Variables
    // --------

    /** Flag to clear the activity on a write operation */
    private boolean clearActivityOnWrite;
    /** Flag to do speed checking */
<span class="nc" id="L147">    private boolean doSpeedEnable = true;</span>
    /** Flag to indicated devices detected on branch during smart-on */
<span class="nc" id="L149">    private boolean devicesOnBranch = false;</span>

    // --------
    // -------- Constructors
    // --------

    /**
     * Create an empty container that is not complete until after a call to
     * &lt;code&gt;setupContainer&lt;/code&gt;.
     * &lt;p&gt;
     * 
     * This is one of the methods to construct a container. The others are
     * through creating a OneWireContainer with parameters.
     * 
     * @see #setupContainer(com.dalsemi.onewire.adapter.DSPortAdapter,byte[])
     *      super.setupContainer()
     */
<span class="nc" id="L166">    public OneWireContainer1F() {</span>

<span class="nc" id="L168">        clearActivityOnWrite = false;</span>
<span class="nc" id="L169">    }</span>

    /**
     * Create a container with the provided adapter instance and the address of
     * the iButton or 1-Wire device.
     * &lt;p&gt;
     * 
     * This is one of the methods to construct a container. The other is through
     * creating a OneWireContainer with NO parameters.
     * 
     * @param sourceAdapter
     *            adapter instance used to communicate with this iButton
     * @param newAddress
     *            {@link com.dalsemi.onewire.utils.Address Address} of this
     *            1-Wire device
     * 
     * @see #OneWireContainer1F() OneWireContainer1F
     * @see com.dalsemi.onewire.utils.Address utils.Address
     */
    public OneWireContainer1F(DSPortAdapter sourceAdapter, byte[] newAddress) {

<span class="nc" id="L190">        super(sourceAdapter, newAddress);</span>

<span class="nc" id="L192">        clearActivityOnWrite = false;</span>
<span class="nc" id="L193">    }</span>

    /**
     * Create a container with the provided adapter instance and the address of
     * the iButton or 1-Wire device.
     * &lt;p&gt;
     * 
     * This is one of the methods to construct a container. The other is through
     * creating a OneWireContainer with NO parameters.
     * 
     * @param sourceAdapter
     *            adapter instance used to communicate with this 1-Wire device
     * @param newAddress
     *            {@link com.dalsemi.onewire.utils.Address Address} of this
     *            1-Wire device
     * 
     * @see #OneWireContainer1F() OneWireContainer1F
     * @see com.dalsemi.onewire.utils.Address utils.Address
     */
    public OneWireContainer1F(DSPortAdapter sourceAdapter, long newAddress) {
<span class="nc" id="L213">        super(sourceAdapter, newAddress);</span>

<span class="nc" id="L215">        clearActivityOnWrite = false;</span>
<span class="nc" id="L216">    }</span>

    /**
     * Create a container with the provided adapter instance and the address of
     * the iButton or 1-Wire device.
     * &lt;p&gt;
     * 
     * This is one of the methods to construct a container. The other is through
     * creating a OneWireContainer with NO parameters.
     * 
     * @param sourceAdapter
     *            adapter instance used to communicate with this 1-Wire device
     * @param newAddress
     *            {@link com.dalsemi.onewire.utils.Address Address} of this
     *            1-Wire device
     * 
     * @see #OneWireContainer1F() OneWireContainer1F
     * @see com.dalsemi.onewire.utils.Address utils.Address
     */
    public OneWireContainer1F(DSPortAdapter sourceAdapter, String newAddress) {
<span class="nc" id="L236">        super(sourceAdapter, newAddress);</span>

<span class="nc" id="L238">        clearActivityOnWrite = false;</span>
<span class="nc" id="L239">    }</span>

    // --------
    // -------- Methods
    // --------

    /**
     * Gets the Dallas Semiconductor part number of the iButton or 1-Wire Device
     * as a string. For example 'DS1992'.
     * 
     * @return iButton or 1-Wire device name
     */
    @Override
    public String getName() {
<span class="nc" id="L253">        return &quot;DS2409&quot;;</span>
    }

    /**
     * Gets the alternate Dallas Semiconductor part numbers or names. A 'family'
     * of 1-Wire Network devices may have more than one part number depending on
     * packaging. There can also be nicknames such as 'Crypto iButton'.
     * 
     * @return 1-Wire device alternate names
     */
    @Override
    public String getAlternateNames() {
<span class="nc" id="L265">        return &quot;Coupler&quot;;</span>
    }

    /**
     * Gets a short description of the function of this iButton or 1-Wire Device
     * type.
     * 
     * @return device description
     */
    @Override
    public String getDescription() {
<span class="nc" id="L276">        return &quot;1-Wire Network Coupler with dual addressable &quot;</span>
                + &quot;switches and a general purpose open drain control &quot;
                + &quot;output.  Provides a common ground for all connected&quot;
                + &quot;multi-level MicroLan networks.  Keeps inactive branches&quot;
                + &quot;Pulled to 5V.&quot;;
    }

    /**
     * Directs the container to avoid the calls to doSpeed() in methods that
     * communicate with the Thermocron. To ensure that all parts can talk to the
     * 1-Wire bus at their desired speed, each method contains a call to
     * &lt;code&gt;doSpeed()&lt;/code&gt;. However, this is an expensive operation. If a
     * user manages the bus speed in an application, call this method with
     * &lt;code&gt;doSpeedCheck&lt;/code&gt; as &lt;code&gt;false&lt;/code&gt;. The default behavior is
     * to call &lt;code&gt;doSpeed()&lt;/code&gt;.
     * 
     * @param doSpeedCheck
     *            &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;doSpeed()&lt;/code&gt; to be called
     *            before every 1-Wire bus access, &lt;code&gt;false&lt;/code&gt; to skip
     *            this expensive call
     * 
     * @see OneWireContainer#doSpeed()
     */
    public synchronized void setSpeedCheck(boolean doSpeedCheck) {
<span class="nc" id="L300">        doSpeedEnable = doSpeedCheck;</span>
<span class="nc" id="L301">    }</span>

    // --------
    // -------- Sensor I/O methods
    // --------

    /**
     * Retrieves the 1-Wire device sensor state. This state is returned as a
     * byte array. Pass this byte array to the 'get' and 'set' methods. If the
     * device state needs to be changed then call the 'writeDevice' to finalize
     * the changes.
     * 
     * @return 1-Wire device sensor state
     * 
     * @throws OneWireIOException
     *             on a 1-Wire communication error such as reading an incorrect
     *             CRC from a 1-Wire device. This could be caused by a physical
     *             interruption in the 1-Wire Network due to shorts or a newly
     *             arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException
     *             on a communication or setup error with the 1-Wire adapter
     *             
     * @deprecated Use {@link #readDevice(byte[])} instead, it doesn't allocate memory.
     */
    @Override
    public byte[] readDevice() throws OneWireIOException, OneWireException {

<span class="nc" id="L328">        byte[] outputBuffer = new byte[4];</span>
        
<span class="nc" id="L330">        readDevice(outputBuffer);</span>

<span class="nc" id="L332">        return outputBuffer;</span>
    }

    @Override
    public void readDevice(byte[] outputBuffer) throws OneWireIOException, OneWireException {

<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (doSpeedEnable) {</span>
<span class="nc" id="L339">            doSpeed();</span>
        }

        // read the status byte
<span class="nc" id="L343">        byte[] tmp_buf = deviceOperation(READ_WRITE_STATUS_COMMAND,</span>
                (byte) 0x00FF, 2);

        // extract the status byte
<span class="nc" id="L347">        outputBuffer[0] = tmp_buf[2];</span>
<span class="nc" id="L348">    }</span>

    /**
     * Writes the 1-Wire device sensor state that have been changed by 'set'
     * methods. Only the state registers that changed are updated. This is done
     * by referencing a field information appended to the state data.
     * 
     * @param state
     *            1-Wire device sensor state
     * 
     * @throws OneWireIOException
     *             on a 1-Wire communication error such as reading an incorrect
     *             CRC from a 1-Wire device. This could be caused by a physical
     *             interruption in the 1-Wire Network due to shorts or a newly
     *             arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException
     *             on a communication or setup error with the 1-Wire adapter
     */
    @Override
    public void writeDevice(byte[] state) throws OneWireIOException,
            OneWireException {

<span class="nc" id="L370">        int extra = 0;</span>
        byte command, first_byte;
<span class="nc" id="L372">        byte[] tmp_buf = null;</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (doSpeedEnable) {</span>
<span class="nc" id="L375">            doSpeed();</span>
        }

        // check for both switches set to on
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if ((Bit.arrayReadBit(MAIN_OFFSET, BITMAP_OFFSET, state) == 1)</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                &amp;&amp; (Bit.arrayReadBit(AUX_OFFSET, BITMAP_OFFSET, state) == 1)) {</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">            if ((state[MAIN_OFFSET] != SWITCH_OFF)</span>
                    &amp;&amp; (state[AUX_OFFSET] != SWITCH_OFF)) {
<span class="nc" id="L383">                throw new OneWireException(address,</span>
                        &quot;Attempting to set both channels on, only single channel on at a time&quot;);
            }
        }

        // check if need to set control
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (Bit.arrayReadBit(STATUS_OFFSET, BITMAP_OFFSET, state) == 1) {</span>

            // create a command based on bit 6/7 of status
<span class="nc" id="L392">            first_byte = 0;</span>

            // mode bit
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (Bit.arrayReadBit(7, STATUS_OFFSET, state) == 1)</span>
<span class="nc" id="L396">                first_byte |= (byte) 0x20;</span>

            // Control output
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (Bit.arrayReadBit(6, STATUS_OFFSET, state) == 1)</span>
<span class="nc" id="L400">                first_byte |= (byte) 0xC0;</span>

<span class="nc" id="L402">            tmp_buf = deviceOperation(READ_WRITE_STATUS_COMMAND, first_byte, 2);</span>
<span class="nc" id="L403">            state[0] = (byte) tmp_buf[2];</span>
        }

        // check for AUX state change
<span class="nc" id="L407">        command = 0;</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (Bit.arrayReadBit(AUX_OFFSET, BITMAP_OFFSET, state) == 1) {</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">            if ((state[AUX_OFFSET] == SWITCH_ON)</span>
                    || (state[AUX_OFFSET] == SWITCH_SMART)) {
<span class="nc" id="L412">                command = SMART_ON_AUX_COMMAND;</span>
<span class="nc" id="L413">                extra = 2;</span>
            } else {
<span class="nc" id="L415">                command = ALL_LINES_OFF_COMMAND;</span>
<span class="nc" id="L416">                extra = 0;</span>
            }
        }

        // check for MAIN state change
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (Bit.arrayReadBit(MAIN_OFFSET, BITMAP_OFFSET, state) == 1) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (state[MAIN_OFFSET] == SWITCH_ON) {</span>
<span class="nc" id="L423">                command = DIRECT_ON_MAIN_COMMAND;</span>
<span class="nc" id="L424">                extra = 0;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            } else if (state[MAIN_OFFSET] == SWITCH_SMART) {</span>
<span class="nc" id="L426">                command = SMART_ON_MAIN_COMMAND;</span>
<span class="nc" id="L427">                extra = 2;</span>
            } else {
<span class="nc" id="L429">                command = ALL_LINES_OFF_COMMAND;</span>
<span class="nc" id="L430">                extra = 0;</span>
            }
        }

        // check if there are events to clear and not about to do clear anyway
<span class="nc bnc" id="L435" title="All 4 branches missed.">        if ((clearActivityOnWrite) &amp;&amp; (command != ALL_LINES_OFF_COMMAND)) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if ((Bit.arrayReadBit(4, STATUS_OFFSET, state) == 1)</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                    || (Bit.arrayReadBit(5, STATUS_OFFSET, state) == 1)) {</span>

                // clear the events
<span class="nc" id="L440">                deviceOperation(ALL_LINES_OFF_COMMAND, (byte) 0xFF, 0);</span>

                // set the channels back to the correct state
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if (command == 0) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    if (Bit.arrayReadBit(0, STATUS_OFFSET, state) == 0) {</span>
<span class="nc" id="L445">                        command = SMART_ON_MAIN_COMMAND;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                    } else if (Bit.arrayReadBit(2, STATUS_OFFSET, state) == 0) {</span>
<span class="nc" id="L447">                        command = SMART_ON_AUX_COMMAND;</span>
                    }

<span class="nc" id="L450">                    extra = 2;</span>
                }
            }
        }

        // check if there is a command to send
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (command != 0) {</span>
<span class="nc" id="L457">            tmp_buf = deviceOperation(command, (byte) 0xFF, extra);</span>
        }

        // if doing a SMART_ON, then look at result data for presence
<span class="nc bnc" id="L461" title="All 4 branches missed.">        if ((command == SMART_ON_MAIN_COMMAND)</span>
                || (command == SMART_ON_AUX_COMMAND)) {
            // devices on branch indicated if 3rd byte is 0
<span class="nc bnc" id="L464" title="All 2 branches missed.">            devicesOnBranch = (tmp_buf[2] == 0);</span>
        } else {
<span class="nc" id="L466">            devicesOnBranch = false;</span>
        }

        // clear clear activity on write
<span class="nc" id="L470">        clearActivityOnWrite = false;</span>

        // clear the bitmap
<span class="nc" id="L473">        state[BITMAP_OFFSET] = 0;</span>
<span class="nc" id="L474">    }</span>

    /**
     * &lt;P&gt;
     * Force a power-on reset for parasitically powered 1-Wire devices connected
     * to the main or auziliary output of the DS2409.
     * &lt;/P&gt;
     * 
     * &lt;P&gt;
     * IMPORTANT: the duration of the discharge time should be 100ms minimum.
     * &lt;/P&gt;
     * &lt;BR&gt;
     * 
     * @param time
     *            number of milliseconds the lines are to be discharged for
     *            (minimum 100)
     * 
     * @throws OneWireIOException
     *             on a 1-Wire communication error such as reading an incorrect
     *             CRC from a 1-Wire device. This could be caused by a physical
     *             interruption in the 1-Wire Network due to shorts or a newly
     *             arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException
     *             on a communication or setup error with the 1-Wire adapter
     */
    public void dischargeLines(int time) throws OneWireIOException,
            OneWireException {

        // Error checking
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (time &lt; 100) {</span>
<span class="nc" id="L504">            time = 100;</span>
        }

<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (doSpeedEnable) {</span>
<span class="nc" id="L508">            doSpeed();</span>
        }

        // discharge the lines
<span class="nc" id="L512">        deviceOperation(DISCHARGE_COMMAND, (byte) 0xFF, 0);</span>

        // wait for desired time and return.
        try {
<span class="nc" id="L516">            Thread.sleep(time);</span>
<span class="nc" id="L517">        } catch (InterruptedException ex) {</span>

            // DRAIN
<span class="nc" id="L520">            logger.debug(&quot;Interrupted&quot;, ex);</span>
<span class="nc" id="L521">        }</span>

        // clear the discharge
<span class="nc" id="L524">        deviceOperation(READ_WRITE_STATUS_COMMAND, (byte) 0x00FF, 2);</span>
<span class="nc" id="L525">    }</span>

    // --------
    // -------- Switch Feature methods
    // --------

    /**
     * Checks to see if the channels of this switch are 'high side' switches.
     * This indicates that when 'on' or &lt;code&gt;true&lt;/code&gt;, the switch output is
     * connect to the 1-Wire data. If this method returns &lt;code&gt;false&lt;/code&gt;
     * then when the switch is 'on' or &lt;code&gt;true&lt;/code&gt;, the switch is
     * connected to ground.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if the switch is a 'high side' switch,
     *         &lt;code&gt;false&lt;/code&gt; if the switch is a 'low side' switch
     * 
     * @see #getLatchState(int,byte[])
     */
    @Override
    public boolean isHighSideSwitch() {
<span class="nc" id="L545">        return true;</span>
    }

    /**
     * Checks to see if the channels of this switch support activity sensing. If
     * this method returns &lt;code&gt;true&lt;/code&gt; then the method
     * &lt;code&gt;getSensedActivity(int,byte[])&lt;/code&gt; can be used.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if channels support activity sensing
     * 
     * @see #getSensedActivity(int,byte[])
     * @see #clearActivity()
     */
    @Override
    public boolean hasActivitySensing() {
<span class="nc" id="L560">        return true;</span>
    }

    /**
     * Checks to see if the channels of this switch support level sensing. If
     * this method returns &lt;code&gt;true&lt;/code&gt; then the method
     * &lt;code&gt;getLevel(int,byte[])&lt;/code&gt; can be used.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if channels support level sensing
     * 
     * @see #getLevel(int,byte[])
     */
    @Override
    public boolean hasLevelSensing() {
<span class="nc" id="L574">        return true;</span>
    }

    /**
     * Checks to see if the channels of this switch support 'smart on'. Smart on
     * is the ability to turn on a channel such that only 1-Wire device on this
     * channel are awake and ready to do an operation. This greatly reduces the
     * time to discover the device down a branch. If this method returns
     * &lt;code&gt;true&lt;/code&gt; then the method
     * &lt;code&gt;setLatchState(int,boolean,boolean,byte[])&lt;/code&gt; can be used with
     * the &lt;code&gt;doSmart&lt;/code&gt; parameter &lt;code&gt;true&lt;/code&gt;.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if channels support 'smart on'
     * 
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean hasSmartOn() {
<span class="nc" id="L592">        return true;</span>
    }

    /**
     * Checks to see if the channels of this switch require that only one
     * channel is on at any one time. If this method returns &lt;code&gt;true&lt;/code&gt;
     * then the method &lt;code&gt;setLatchState(int,boolean,boolean,byte[])&lt;/code&gt;
     * will not only affect the state of the given channel but may affect the
     * state of the other channels as well to insure that only one channel is on
     * at a time.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if only one channel can be on at a time.
     * 
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean onlySingleChannelOn() {
<span class="nc" id="L609">        return true;</span>
    }

    // --------
    // -------- Switch 'get' Methods
    // --------

    /**
     * Query to get the number of channels supported by this switch. Channel
     * specific methods will use a channel number specified by an integer from
     * [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]. Note that all
     * devices of the same family will not necessarily have the same number of
     * channels. The DS2406 comes in two packages--one that has a single
     * channel, and one that has two channels.
     * 
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @return the number of channels for this device
     */
    @Override
    public int getNumberChannels(byte[] state) {
<span class="nc" id="L632">        return 2;</span>
    }

    /**
     * Checks the sensed level on the indicated channel. To avoid an exception,
     * verify that this switch has level sensing with the
     * &lt;code&gt;hasLevelSensing()&lt;/code&gt;. Level sensing means that the device can
     * sense the logic level on its PIO pin.
     * 
     * @param channel
     *            channel to execute this operation, in the range [0 to (
     *            &lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if level sensed is 'high' and
     *         &lt;code&gt;false&lt;/code&gt; if level sensed is 'low'
     * 
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #hasLevelSensing()
     */
    @Override
    public boolean getLevel(int channel, byte[] state) throws OneWireException {
<span class="nc bnc" id="L656" title="All 2 branches missed.">        return (Bit.arrayReadBit(1 + channel * 2, STATUS_OFFSET, state) == 1);</span>
    }

    /**
     * Checks the latch state of the indicated channel.
     * 
     * @param channel
     *            channel to execute this operation, in the range [0 to (
     *            &lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if channel latch is 'on' or conducting and
     *         &lt;code&gt;false&lt;/code&gt; if channel latch is 'off' and not conducting.
     *         Note that the actual output when the latch is 'on' is returned
     *         from the &lt;code&gt;isHighSideSwitch()&lt;/code&gt; method.
     * 
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #isHighSideSwitch()
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean getLatchState(int channel, byte[] state) {
<span class="nc bnc" id="L680" title="All 2 branches missed.">        return (Bit.arrayReadBit(channel * 2, STATUS_OFFSET, state) == 0);</span>
    }

    /**
     * Checks if the indicated channel has experienced activity. This occurs
     * when the level on the PIO pins changes. To clear the activity that is
     * reported, call &lt;code&gt;clearActivity()&lt;/code&gt;. To avoid an exception,
     * verify that this device supports activity sensing by calling the method
     * &lt;code&gt;hasActivitySensing()&lt;/code&gt;.
     * 
     * @param channel
     *            channel to execute this operation, in the range [0 to (
     *            &lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if activity was detected and &lt;code&gt;false&lt;/code&gt;
     *         if no activity was detected
     * 
     * @throws OneWireException
     *             if this device does not have activity sensing
     * 
     * @see #hasActivitySensing()
     * @see #clearActivity()
     */
    @Override
    public boolean getSensedActivity(int channel, byte[] state)
            throws OneWireException {
<span class="nc bnc" id="L709" title="All 2 branches missed.">        return (Bit.arrayReadBit(4 + channel, STATUS_OFFSET, state) == 1);</span>
    }

    // --------
    // -------- DS2409 Specific Switch 'get' Methods
    // --------

    /**
     * Checks if the control I/O pin mode is automatic (see DS2409 data sheet).
     * 
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if control mode is automatic
     */
    public boolean isModeAuto(byte[] state) {
<span class="nc bnc" id="L726" title="All 2 branches missed.">        return (Bit.arrayReadBit(7, STATUS_OFFSET, state) == 0);</span>
    }

    /**
     * Checks the channel association of the control pin. This value only makes
     * sense if the control mode is automatic (see &lt;CODE&gt;isModeAuto&lt;/CODE&gt;).
     * 
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @return &lt;code&gt;int&lt;/code&gt; the channel number that is associated with the
     *         control pin
     */
    public int getControlChannelAssociation(byte[] state) {
<span class="nc" id="L741">        return Bit.arrayReadBit(6, STATUS_OFFSET, state);</span>
    }

    /**
     * Checks the control data value. This value only makes sense if the control
     * mode is manual (see &lt;CODE&gt;isModeAuto&lt;/CODE&gt;). 0 = output transistor off,
     * 1 = output transistor on
     * 
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @return &lt;code&gt;int&lt;/code&gt; the control output transistor state
     */
    public int getControlData(byte[] state) {
<span class="nc" id="L756">        return Bit.arrayReadBit(6, STATUS_OFFSET, state);</span>
    }

    /**
     * Gets flag that indicates if a device was present when doing the last
     * smart on. Note that this flag is only valid if the DS2409 flag was
     * cleared with an ALL_LINES_OFF command and the last writeDevice performed
     * a 'smart-on' on one of the channels.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if device detected on branch
     */
    public boolean getLastSmartOnDeviceDetect() {
<span class="nc" id="L768">        return devicesOnBranch;</span>
    }

    // --------
    // -------- Switch 'set' Methods
    // --------

    /**
     * Sets the latch state of the indicated channel. The method
     * &lt;code&gt;writeDevice(byte[])&lt;/code&gt; must be called to finalize changes to
     * the device. Note that multiple 'set' methods can be called before one
     * call to &lt;code&gt;writeDevice(byte[])&lt;/code&gt;.
     * 
     * @param channel
     *            channel to execute this operation, in the range [0 to (
     *            &lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param latchState
     *            &lt;code&gt;true&lt;/code&gt; to set the channel latch 'on' (conducting)
     *            and &lt;code&gt;false&lt;/code&gt; to set the channel latch 'off' (not
     *            conducting). Note that the actual output when the latch is
     *            'on' is returned from the &lt;code&gt;isHighSideSwitch()&lt;/code&gt;
     *            method.
     * @param doSmart
     *            If latchState is 'on'/&lt;code&gt;true&lt;/code&gt; then doSmart indicates
     *            if a 'smart on' is to be done. To avoid an exception check the
     *            capabilities of this device using the
     *            &lt;code&gt;hasSmartOn()&lt;/code&gt; method.
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @see #hasSmartOn()
     * @see #getLatchState(int,byte[])
     * @see com.dalsemi.onewire.container.OneWireSensor#writeDevice(byte[])
     */
    @Override
    public void setLatchState(int channel, boolean latchState, boolean doSmart,
            byte[] state) {

        // set the state flag
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (latchState) {</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">            state[channel + 1] = (byte) ((doSmart) ? SWITCH_SMART : SWITCH_ON);</span>
        } else {
<span class="nc" id="L811">            state[channel + 1] = (byte) SWITCH_OFF;</span>
        }

        // indicate in bitmap the the state has changed
<span class="nc" id="L815">        Bit.arrayWriteBit(1, channel + 1, BITMAP_OFFSET, state);</span>
<span class="nc" id="L816">    }</span>

    /**
     * Clears the activity latches the next time possible. For example, on a
     * DS2406/07, this happens the next time the status is read with
     * &lt;code&gt;readDevice()&lt;/code&gt;.
     * 
     * @throws OneWireException
     *             if this device does not support activity sensing
     * 
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #getSensedActivity(int,byte[])
     */
    @Override
    public void clearActivity() throws OneWireException {
<span class="nc" id="L831">        clearActivityOnWrite = true;</span>
<span class="nc" id="L832">    }</span>

    // --------
    // -------- DS2409 Specific Switch 'set' Methods
    // --------

    /**
     * Sets the control pin mode. The method &lt;code&gt;writeDevice(byte[])&lt;/code&gt;
     * must be called to finalize changes to the device. Note that multiple
     * 'set' methods can be called before one call to
     * &lt;code&gt;writeDevice(byte[])&lt;/code&gt;.
     * 
     * @param makeAuto
     *            &lt;CODE&gt;true&lt;/CODE&gt; to set to auto mode, false for manual mode
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     */
    public void setModeAuto(boolean makeAuto, byte[] state) {
        // set the bit
<span class="nc bnc" id="L852" title="All 2 branches missed.">        Bit.arrayWriteBit((makeAuto ? 0 : 1), 7, STATUS_OFFSET, state);</span>

        // indicate in bitmap the the state has changed
<span class="nc" id="L855">        Bit.arrayWriteBit(1, STATUS_OFFSET, BITMAP_OFFSET, state);</span>
<span class="nc" id="L856">    }</span>

    /**
     * Sets the control pin channel association. This only makes sense if the
     * contol pin is in automatic mode. The method
     * &lt;code&gt;writeDevice(byte[])&lt;/code&gt; must be called to finalize changes to
     * the device. Note that multiple 'set' methods can be called before one
     * call to &lt;code&gt;writeDevice(byte[])&lt;/code&gt;.
     * 
     * @param channel
     *            channel to associate with control pin
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @throws OneWireException
     *             when trying to set channel association in manual mode
     */
    public void setControlChannelAssociation(int channel, byte[] state)
            throws OneWireException {

        // check for invalid mode
<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (!isModeAuto(state)) {</span>
<span class="nc" id="L879">            throw new OneWireException(address,</span>
                    &quot;Trying to set channel association in manual mode&quot;);
        }

        // set the bit
<span class="nc" id="L884">        Bit.arrayWriteBit(channel, 6, STATUS_OFFSET, state);</span>

        // indicate in bitmap the the state has changed
<span class="nc" id="L887">        Bit.arrayWriteBit(1, STATUS_OFFSET, BITMAP_OFFSET, state);</span>
<span class="nc" id="L888">    }</span>

    /**
     * Sets the control pin data to a value. Note this method only works if the
     * control pin is in manual mode. The method
     * &lt;code&gt;writeDevice(byte[])&lt;/code&gt; must be called to finalize changes to
     * the device. Note that multiple 'set' methods can be called before one
     * call to &lt;code&gt;writeDevice(byte[])&lt;/code&gt;.
     * 
     * @param data
     *            &lt;CODE&gt;true&lt;/CODE&gt; for on and &lt;CODE&gt;false&lt;/CODE&gt; for off
     * @param state
     *            current state of the device returned from
     *            &lt;code&gt;readDevice()&lt;/code&gt;
     * 
     * @throws OneWireException
     *             when trying to set control data in automatic mode
     */
    public void setControlData(boolean data, byte[] state)
            throws OneWireException {

        // check for invalid mode
<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (isModeAuto(state)) {</span>
<span class="nc" id="L911">            throw new OneWireException(address,</span>
                    &quot;Trying to set control data when control is in automatic mode&quot;);
        }

        // set the bit
<span class="nc bnc" id="L916" title="All 2 branches missed.">        Bit.arrayWriteBit((data ? 1 : 0), 6, STATUS_OFFSET, state);</span>

        // indicate in bitmap the the state has changed
<span class="nc" id="L919">        Bit.arrayWriteBit(1, STATUS_OFFSET, BITMAP_OFFSET, state);</span>
<span class="nc" id="L920">    }</span>

    // --------
    // -------- Private methods
    // --------

    /**
     * Do a DS2409 specidific operation.
     * 
     * @param command
     *            code to send
     * @param sendByte
     *            data byte to send
     * @param extra
     *            number of extra bytes to send
     * 
     * @return block of the complete resulting transaction
     * 
     * @throws OneWireIOException
     *             on a 1-Wire communication error such as reading an incorrect
     *             CRC from a 1-Wire device. This could be caused by a physical
     *             interruption in the 1-Wire Network due to shorts or a newly
     *             arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException
     *             on a communication or setup error with the 1-Wire adapter
     */
    private byte[] deviceOperation(byte command, byte sendByte, int extra)
            throws OneWireIOException, OneWireException {

<span class="nc" id="L949">        OneWireIOException exc = null;</span>

<span class="nc bnc" id="L951" title="All 2 branches missed.">        for (int attemptCounter = 2; attemptCounter &gt; 0; attemptCounter--) {</span>
            // Variables.
<span class="nc" id="L953">            byte[] raw_buf = new byte[extra + 2];</span>

            // build block.
<span class="nc" id="L956">            raw_buf[0] = (byte) command;</span>
<span class="nc" id="L957">            raw_buf[1] = (byte) sendByte;</span>

<span class="nc bnc" id="L959" title="All 2 branches missed.">            for (int i = 2; i &lt; raw_buf.length; i++) {</span>
<span class="nc" id="L960">                raw_buf[i] = (byte) 0xFF;</span>
            }

            // Select the device.
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (adapter.select(address)) {</span>

                // send the block
<span class="nc" id="L967">                adapter.dataBlock(raw_buf, 0, raw_buf.length);</span>

                // verify
<span class="nc bnc" id="L970" title="All 2 branches missed.">                if (command == READ_WRITE_STATUS_COMMAND) {</span>

<span class="nc bnc" id="L972" title="All 2 branches missed.">                    if ((byte) raw_buf[raw_buf.length - 1] != (byte) raw_buf[raw_buf.length - 2]) {</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">                        if (exc == null) {</span>
<span class="nc" id="L975">                            exc = new OneWireIOException(address,</span>
                                    &quot;OneWireContainer1F verify on command incorrect&quot;);
                        }

                        continue;
                    }
                } else {
<span class="nc bnc" id="L982" title="All 2 branches missed.">                    if ((byte) raw_buf[raw_buf.length - 1] != (byte) command) {</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                        if (exc == null) {</span>
<span class="nc" id="L984">                            exc = new OneWireIOException(address, &quot;OneWireContainer1F verify on command incorrect&quot;);</span>
                        }
                        continue;
                    }
                }

<span class="nc" id="L990">                return raw_buf;</span>
                
            } else {

<span class="nc" id="L994">                throw new OneWireIOException(address, &quot;OneWireContainer1F failure - Device not found&quot;);</span>
            }
        }
        // get here after a few attempts
<span class="nc" id="L998">        throw exc;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>