<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OneWireContainer12.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OWAPI 1.00 refactored for DIY Zoning</a> &gt; <a href="index.source.html" class="el_package">com.dalsemi.onewire.container</a> &gt; <span class="el_source">OneWireContainer12.java</span></div><h1>OneWireContainer12.java</h1><pre class="source lang-java linenums">
/*---------------------------------------------------------------------------
 * Copyright (C) 1999,2000 Dallas Semiconductor Corporation, All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL DALLAS SEMICONDUCTOR BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Dallas Semiconductor
 * shall not be used except as stated in the Dallas Semiconductor
 * Branding Policy.
 *---------------------------------------------------------------------------
 */

package com.dalsemi.onewire.container;

import java.util.Enumeration;
import java.util.Vector;

import com.dalsemi.onewire.OneWireException;
import com.dalsemi.onewire.adapter.DSPortAdapter;
import com.dalsemi.onewire.adapter.OneWireIOException;
import com.dalsemi.onewire.utils.CRC16;

/**
 * &lt;P&gt; 1-Wire&amp;#174 container for a Dual Addressable Switch, DS2406 or DS2407.
 * This container encapsulates the functionality of the 1-Wire family type &lt;B&gt;12&lt;/B&gt; (hex).
 * The DS2406 replaces the DS2407, but does not have hidden mode or user programmable
 * power-on settings.&lt;/P&gt;
 *
 * &lt;H3&gt; Features &lt;/H3&gt;
 * &lt;UL&gt;
 *   &lt;LI&gt; Open drain PIO pin controlled through 1-Wire communication
 *   &lt;li&gt; 1024-bits of user programmable OTP EPROM
 *   &lt;LI&gt; Operating temperature range from -40&amp;#176C to +85&amp;#176C
 *   &lt;li&gt; On-chip CRC16 generator allows detection of data transfer errors
 *   &lt;li&gt; One or two channels with level sensing abilities
 *   &lt;li&gt; Supports activity sensing
 *   &lt;li&gt; Does not support 'Smart On' capabilities
 *   &lt;li&gt; TO-92 (1 channel) or TSOC (2 channel) packaging
 *   &lt;li&gt; Supports Conditional Search with user-selectable search options
 * &lt;/UL&gt;
 *
 * &lt;H3&gt; Memory &lt;/H3&gt;
 *
 * &lt;P&gt; The memory can be accessed through the objects that are returned
 * from the {@link #getMemoryBanks() getMemoryBanks} method. &lt;/P&gt;
 *
 * The following is a list of the MemoryBank instances that are returned:
 *
 * &lt;UL&gt;
 *   &lt;LI&gt; &lt;B&gt; Main Memory &lt;/B&gt;
 *      &lt;UL&gt;
 *         &lt;LI&gt; &lt;I&gt; Implements &lt;/I&gt; {@link com.dalsemi.onewire.container.MemoryBank MemoryBank},
 *                  {@link com.dalsemi.onewire.container.PagedMemoryBank PagedMemoryBank},
 *                  {@link com.dalsemi.onewire.container.OTPMemoryBank OTPMemoryBank}
 *         &lt;LI&gt; &lt;I&gt; Size &lt;/I&gt; 128 starting at physical address 0
 *         &lt;LI&gt; &lt;I&gt; Features&lt;/I&gt; Write-once general-purpose non-volatile needs-program-pulse
 *         &lt;LI&gt; &lt;I&gt; Pages&lt;/I&gt; 4 pages of length 32 bytes giving 29 bytes Packet data payload
 *         &lt;LI&gt; &lt;I&gt; Page Features &lt;/I&gt; page-device-CRC pages-redirectable pages-lockable
 *         &lt;li&gt; &lt;i&gt; Extra information for each page&lt;/i&gt;  Inverted redirection page, length 1
 *      &lt;/UL&gt;
 *   &lt;LI&gt; &lt;B&gt; Write protect pages and Page redirection &lt;/B&gt;
 *      &lt;UL&gt;
 *         &lt;LI&gt; &lt;I&gt; Implements &lt;/I&gt; {@link com.dalsemi.onewire.container.MemoryBank MemoryBank},
 *                  {@link com.dalsemi.onewire.container.PagedMemoryBank PagedMemoryBank},
 *                  {@link com.dalsemi.onewire.container.OTPMemoryBank OTPMemoryBank}
 *         &lt;LI&gt; &lt;I&gt; Size &lt;/I&gt; 8 starting at physical address 0 (in STATUS memory area)
 *         &lt;LI&gt; &lt;I&gt; Features&lt;/I&gt; Write-once not-general-purpose non-volatile needs-program-pulse
 *         &lt;LI&gt; &lt;I&gt; Pages&lt;/I&gt; 1 pages of length 8 bytes
 *         &lt;LI&gt; &lt;I&gt; Page Features &lt;/I&gt; page-device-CRC
 *      &lt;/UL&gt;
 * &lt;/UL&gt;
 *
 * &lt;H3&gt; Usage &lt;/H3&gt;
 *
 * &lt;p&gt;The DS2406 supports level sensing and activity sensing.  The code below
 * reports the flip-flop state, PIO level, and sensed activity while toggling
 * every switch each time through the loop.  It toggles every switch it finds,
 * regardless if the device has one or two switches.&lt;/p&gt;
 *
 * &lt;code&gt;&lt;pre&gt;
 *      // &quot;ID&quot; is a byte array of size 8 with an address of a part we
 *      // have already found with family code 12 hex
 *      // &quot;access&quot; is a DSPortAdapter
 *
 *      OneWireContainer12 ds2406 = (OneWireContainer12) access.getDeviceContainer(ID);
 *      ds2406.setupContainer(access,ID);
 *
 *      byte[] state = ds2406.readDevice();
 *      int numchannels = ds2406.getNumberChannels(state);
 *      System.out.println(&quot;Number of Channels: &quot;+numchannels);
 *      boolean[] switches = new boolean[numchannels];
 *
 *      ds2406.clearActivity();
 *
 *      for (int j=0;j&lt;10;j++)
 *      {
 *          //clear the activity latches halfway through the test
 *          if (j==5)
 *              ds2406.clearActivity();
 *          state = ds2406.readDevice();
 *
 *          //first let's print out the status of all the latches
 *          for (int i=0;i &amp;lt; numchannels;i++)
 *          {
 *              System.out.println(&quot;---------------------------------------------------------\r\n&quot;);
 *              System.out.println(&quot;                       CHANNEL &quot;+i);
 *              System.out.println(&quot;---------------------------------------------------------\r\n&quot;);
 *
 *              System.out.println(&quot;           Latch state: &quot;+ds2406.getLatchState(i,state));
 *              System.out.println(&quot;           Level      : &quot;+ds2406.getLevel(i,state));
 *              System.out.println(&quot;           Activity   : &quot;+ds2406.getSensedActivity(i, state));
 *              switches[i] = ds2406.getLatchState(i,state);
 *          }
 *
 *          //now lets toggle the switch flip-flop
 *          for (int i=0;i &amp;lt; numchannels;i++)
 *          {
 *              ds2406.setLatchState(i,!switches[i],false,state);
 *          }
 *          ds2406.writeDevice(state);
 *
 *          Thread.sleep(500);
 *      }
 *
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * &lt;p&gt;Also see the usage example in the {@link com.dalsemi.onewire.container.SwitchContainer SwithContainer}
 * interface.&lt;/p&gt;
 *
 * For examples regarding memory operations,
 * &lt;uL&gt;
 * &lt;li&gt; See the usage example in
 * {@link com.dalsemi.onewire.container.OneWireContainer OneWireContainer}
 * to enumerate the MemoryBanks.
 * &lt;li&gt; See the usage examples in
 * {@link com.dalsemi.onewire.container.MemoryBank MemoryBank} and
 * {@link com.dalsemi.onewire.container.PagedMemoryBank PagedMemoryBank}
 * for bank specific operations.
 * &lt;/uL&gt;
 *
 * &lt;H3&gt; DataSheet &lt;/H3&gt;
 * &lt;DL&gt;
 * &lt;DD&gt;&lt;A HREF=&quot;http://pdfserv.maxim-ic.com/arpdf/DS2406.pdf&quot;&gt; http://pdfserv.maxim-ic.com/arpdf/DS2406.pdf for the DS2406&lt;/A&gt;
 * &lt;DD&gt;&lt;A HREF=&quot;http://pdfserv.maxim-ic.com/arpdf/DS2407.pdf&quot;&gt; http://pdfserv.maxim-ic.com/arpdf/DS2407.pdf for the DS2407&lt;/A&gt;
 * &lt;/DL&gt;
 *
 * Also see the {@link com.dalsemi.onewire.container.OneWireContainer05 DS2405}, a single addressable switch (OneWireContainer05).
 *
 * @see com.dalsemi.onewire.container.OneWireSensor
 * @see com.dalsemi.onewire.container.SwitchContainer
 * @see com.dalsemi.onewire.container.OneWireContainer05
 *
 *  @version    0.00, 28 Aug 2000
 *  @author     KLA,DSS
 * @author Stability enhancements &amp;copy; &lt;a href=&quot;mailto:vt@freehold.crocodile.org&quot;&gt; Vadim Tkachenko&lt;/a&gt; 2001-2009
 */
public class OneWireContainer12 extends OneWireContainer implements SwitchContainer {

    //--------
    //-------- Static Final Variables
    //--------

    /**
     * Used to set the &lt;code&gt;source&lt;/code&gt; to the activity latch for
     * conditional searches in the &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte SOURCE_ACTIVITY_LATCH = (byte) 0x02;

    /**
     * Used to set the &lt;code&gt;source&lt;/code&gt; to the flip-flop state for
     * conditional searches in the &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte SOURCE_FLIP_FLOP      = (byte) 0x04;

    /**
     * Used to set the &lt;code&gt;source&lt;/code&gt; to the PIO status for
     * conditional searches in the &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte SOURCE_PIO            = (byte) 0x06;


    /**
     * Used to set the &lt;code&gt;polarity&lt;/code&gt; to logical '0' for conditional search
     * checking in the &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte POLARITY_ZERO = 0x00;

    /**
     * Used to set the &lt;code&gt;polarity&lt;/code&gt; to logical '1' for conditional search
     * checking in the &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte POLARITY_ONE  = 0x01;

    /**
     * Used to select neither channel as the source for alarm conditions in the
     * &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte CHANNEL_NONE = 0x00;

    /**
     * Used for options in the &lt;code&gt;setSearchConditions()&lt;/code&gt; to
     * make sure the specified option is not changes from its current
     * value.
     *
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte DONT_CHANGE = (byte)0x0ff;

    /**
     * &lt;code&gt;channelMode&lt;/code&gt; for the &lt;code&gt;channelAccess&lt;/code&gt; method.
     * Selects Channel A (channel 0) for communication.  Also used to
     * select Channel A as the source for alarm conditions in the
     * &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #channelAccess(byte[],boolean,boolean,int,int,boolean,boolean)
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte CHANNEL_A_ONLY = 0x04;

    /**
     * &lt;code&gt;channelMode&lt;/code&gt; for the &lt;code&gt;channelAccess&lt;/code&gt; method.
     * Selects Channel B (channel 1) for communication.  Also used to
     * select Channel B as the source for alarm conditions in the
     * &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #channelAccess(byte[],boolean,boolean,int,int,boolean,boolean)
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte CHANNEL_B_ONLY = 0x08;

    /**
     * &lt;code&gt;channelMode&lt;/code&gt; for the &lt;code&gt;channelAccess&lt;/code&gt; method.
     * Selects both Channel A and B (channel 0 and 1) for communication.  Also used to
     * select both channels as the source for alarm conditions in the
     * &lt;code&gt;setSearchConditions()&lt;/code&gt; method.
     *
     * @see #channelAccess(byte[],boolean,boolean,int,int,boolean,boolean)
     * @see #setSearchConditions(byte,byte,byte,byte[])
     */
    public static final byte CHANNEL_BOTH = 0x0c;

    /**
     * &lt;code&gt;CRCMode&lt;/code&gt; for the &lt;code&gt;channelAccess&lt;/code&gt; method.
     * Requests no CRC generation by the DS2406/2407.
     *
     * @see #channelAccess(byte[],boolean,boolean,int,int,boolean,boolean)
     */
    public static final byte CRC_DISABLE = 0x00;

    /**
     * &lt;code&gt;CRCMode&lt;/code&gt; for the &lt;code&gt;channelAccess&lt;/code&gt; method.
     * Requests CRC generation after every byte transmitted.
     *
     * @see #channelAccess(byte[],boolean,boolean,int,int,boolean,boolean)
     */
    public static final byte CRC_EVERY_BYTE = 0x01;

    /**
     * &lt;code&gt;CRCMode&lt;/code&gt; for the &lt;code&gt;channelAccess&lt;/code&gt; method.
     * Requests CRC generation after every 8 bytes transmitted.
     *
     * @see #channelAccess(byte[],boolean,boolean,int,int,boolean,boolean)
     */
    public static final byte CRC_EVERY_8_BYTES = 0x02;

    /**
     * &lt;code&gt;CRCMode&lt;/code&gt; for the &lt;code&gt;channelAccess&lt;/code&gt; method.
     * Requests CRC generation after every 32 bytes transmitted.
     *
     * @see #channelAccess(byte[],boolean,boolean,int,int,boolean,boolean)
     */
    public static final byte CRC_EVERY_32_BYTES = 0x03;



    // privates !

    /* DS2406 Write status command                                */
    private static final byte WRITE_STATUS_COMMAND = 0x55;
    /* DS2406 channel access command                              */
    private static final byte CHANNEL_ACCESS_COMMAND = ( byte ) 0xF5;
    /* internal buffer  */
<span class="nc" id="L311">    private byte[]  buffer        = new byte [7];</span>
<span class="nc" id="L312">    private boolean clearactivity = false;</span>
<span class="nc" id="L313">    private boolean    doSpeedEnable = true;</span>

    //--------
    //-------- Variables
    //--------
    //--------
    //-------- Constructor
    //--------

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2406/2407.
     * Note that the method &lt;code&gt;setupContainer(com.dalsemi.onewire.adapter.DSPortAdapter,byte[])&lt;/code&gt;
     * must be called to set the correct &lt;code&gt;DSPortAdapter&lt;/code&gt; device address.
     *
     * @see com.dalsemi.onewire.container.OneWireContainer#setupContainer(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) setupContainer(DSPortAdapter,byte[])
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) OneWireContainer12(DSPortAdapter,byte[])
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,long)   OneWireContainer12(DSPortAdapter,long)
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,java.lang.String) OneWireContainer12(DSPortAdapter,String)
     */
<span class="nc" id="L332">    public OneWireContainer12() {</span>
<span class="nc" id="L333">    }</span>

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2406/2407.
     *
     * @param  sourceAdapter     adapter object required to communicate with
     * this 1-Wire device
     * @param  newAddress        address of this DS2406/2407
     *
     * @see #OneWireContainer12()
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,long)   OneWireContainer12(DSPortAdapter,long)
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,java.lang.String) OneWireContainer12(DSPortAdapter,String)
     */
    public OneWireContainer12(DSPortAdapter sourceAdapter, byte[] newAddress) {
<span class="nc" id="L347">        super(sourceAdapter, newAddress);</span>
<span class="nc" id="L348">    }</span>

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2406/2407.
     *
     * @param  sourceAdapter     adapter object required to communicate with
     * this 1-Wire device
     * @param  newAddress        address of this DS2406/2407
     *
     * @see #OneWireContainer12()
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) OneWireContainer12(DSPortAdapter,byte[])
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,java.lang.String) OneWireContainer12(DSPortAdapter,String)
     */
    public OneWireContainer12(DSPortAdapter sourceAdapter, long newAddress) {
<span class="nc" id="L362">        super(sourceAdapter, newAddress);</span>
<span class="nc" id="L363">    }</span>

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2406/2407.
     *
     * @param  sourceAdapter     adapter object required to communicate with
     * this 1-Wire device
     * @param  newAddress        address of this DS2406/2407
     *
     * @see #OneWireContainer12()
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) OneWireContainer12(DSPortAdapter,byte[])
     * @see #OneWireContainer12(com.dalsemi.onewire.adapter.DSPortAdapter,long)   OneWireContainer12(DSPortAdapter,long)
     */
    public OneWireContainer12(DSPortAdapter sourceAdapter, String newAddress) {
<span class="nc" id="L377">        super(sourceAdapter, newAddress);</span>
<span class="nc" id="L378">    }</span>

    //--------
    //-------- Information Methods
    //--------

    /**
     * Gets the Dallas Semiconductor part number of the iButton
     * or 1-Wire Device as a &lt;code&gt;java.lang.String&lt;/code&gt;.
     * For example &quot;DS1992&quot;.
     *
     * @return iButton or 1-Wire device name
     */
    @Override
    public String getName() {
<span class="nc" id="L393">        return &quot;DS2406&quot;;</span>
    }

    /**
     * Retrieves the alternate Dallas Semiconductor part numbers or names.
     * A 'family' of MicroLAN devices may have more than one part number
     * depending on packaging.  There can also be nicknames such as
     * &quot;Crypto iButton&quot;.
     *
     * @return  the alternate names for this iButton or 1-Wire device
     */
    @Override
    public String getAlternateNames() {
<span class="nc" id="L406">        return &quot;Dual Addressable Switch, DS2407&quot;;</span>
    }

    /**
     * Gets a short description of the function of this iButton
     * or 1-Wire Device type.
     *
     * @return device description
     */
    @Override
    public String getDescription() {
<span class="nc" id="L417">        return &quot;1-Wire Dual Addressable Switch.  PIO pin channel &quot;</span>
        + &quot;A sink capability of typical 50mA at 0.4V with &quot;
        + &quot;soft turn-on; optional channel B typical 10 mA at &quot;
        + &quot;0.4V.  1024 bits of Electrically Programmable &quot;
        + &quot;Read Only Memory (EPROM) partitioned into four 256 &quot;
        + &quot;bit pages.  7 bytes of user-programmable status &quot;
        + &quot;memory to control the device.&quot;;
    }

    /**
     * Gets an enumeration of memory bank instances that implement one or more
     * of the following interfaces:
     * {@link com.dalsemi.onewire.container.MemoryBank MemoryBank},
     * {@link com.dalsemi.onewire.container.PagedMemoryBank PagedMemoryBank},
     * and {@link com.dalsemi.onewire.container.OTPMemoryBank OTPMemoryBank}.
     * @return &lt;CODE&gt;Enumeration&lt;/CODE&gt; of memory banks
     */
    @Override
    public Enumeration&lt;MemoryBank&gt; getMemoryBanks() {

<span class="nc" id="L437">        Vector&lt;MemoryBank&gt; bank_vector = new Vector&lt;MemoryBank&gt;(2);</span>

        // EPROM main bank
<span class="nc" id="L440">        MemoryBankEPROM mn = new MemoryBankEPROM(this);</span>

<span class="nc" id="L442">        mn.numberPages = 4;</span>
<span class="nc" id="L443">        mn.size        = 128;</span>

<span class="nc" id="L445">        bank_vector.addElement(mn);</span>

        // EPROM status write protect pages bank
<span class="nc" id="L448">        MemoryBankEPROM st = new MemoryBankEPROM(this);</span>

<span class="nc" id="L450">        st.bankDescription      =</span>
            &quot;Write protect pages, Page redirection, Switch control&quot;;
<span class="nc" id="L452">        st.numberPages          = 1;</span>
<span class="nc" id="L453">        st.size                 = 8;</span>
<span class="nc" id="L454">        st.pageLength           = 8;</span>
<span class="nc" id="L455">        st.generalPurposeMemory = false;</span>
<span class="nc" id="L456">        st.extraInfo            = false;</span>
<span class="nc" id="L457">        st.extraInfoLength      = 0;</span>
<span class="nc" id="L458">        st.extraInfoDescription = null;</span>
<span class="nc" id="L459">        st.crcAfterAddress      = false;</span>
<span class="nc" id="L460">        st.READ_PAGE_WITH_CRC   = MemoryBankEPROM.STATUS_READ_PAGE_COMMAND;</span>
<span class="nc" id="L461">        st.WRITE_MEMORY_COMMAND = MemoryBankEPROM.STATUS_WRITE_COMMAND;</span>

<span class="nc" id="L463">        bank_vector.addElement(st);</span>

        // setup OTP features in main memory
<span class="nc" id="L466">        mn.mbLock         = st;</span>
<span class="nc" id="L467">        mn.lockPage       = true;</span>
<span class="nc" id="L468">        mn.mbRedirect     = st;</span>
<span class="nc" id="L469">        mn.redirectOffset = 1;</span>
<span class="nc" id="L470">        mn.redirectPage   = true;</span>

<span class="nc" id="L472">        return bank_vector.elements();</span>
    }

    //--------
    //-------- Custom Methods for this 1-Wire Device Type
    //--------

    /**
     * Checks to see how the DS2406 is being supplied with power.
     * The 6-pin (2 channel) package of the DS2406 can be powered
     * by an outside source, but will still function on
     * parasite power only.
     *
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return  &lt;code&gt;true&lt;/code&gt; if the device is getting supplied with
     * power and &lt;code&gt;false&lt;/code&gt; if the device is parasite powered
     *
     * @see OneWireSensor#readDevice()
     */
    public boolean isPowerSupplied(byte[] state) {
<span class="nc bnc" id="L493" title="All 2 branches missed.">        return ((state[0] &amp; 0x80) == 0x80);</span>
    }

    /**
     * Gets the number of channels supported by this switch.
     * Channel specific methods will use a channel number specified
     * by an integer from [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)].  Note that
     * all devices of the same family will not necessarily have the
     * same number of channels.
     *
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return the number of channels for this device
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     */
    @Override
    public int getNumberChannels(byte[] state) {
<span class="nc bnc" id="L511" title="All 2 branches missed.">        return ((state[0] &amp; 0x40) == 0x40) ? 2 : 1;</span>
    }

    /**
     * Checks if the channels of this switch are 'high side'
     * switches.  This indicates that when 'on' or &lt;code&gt;true&lt;/code&gt;, the switch output is
     * connect to the 1-Wire data.  If this method returns  &lt;code&gt;false&lt;/code&gt;
     * then when the switch is 'on' or &lt;code&gt;true&lt;/code&gt;, the switch is connected
     * to ground.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the switch is a 'high side' switch,
     *         &lt;code&gt;false&lt;/code&gt; if the switch is a 'low side' switch
     *
     * @see #getLatchState(int,byte[])
     */
    @Override
    public boolean isHighSideSwitch() {
<span class="nc" id="L528">        return false;</span>
    }

    /**
     * Checks if the channels of this switch support
     * activity sensing.  If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;getSensedActivity(int,byte[])&lt;/code&gt; can be used.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channels support activity sensing
     *
     * @see #getSensedActivity(int,byte[])
     * @see #clearActivity()
     */
    @Override
    public boolean hasActivitySensing() {
<span class="nc" id="L543">        return true;</span>
    }

    /**
     * Checks if the channels of this switch support
     * level sensing.  If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;getLevel(int,byte[])&lt;/code&gt; can be used.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channels support level sensing
     *
     * @see #getLevel(int,byte[])
     */
    @Override
    public boolean hasLevelSensing() {
<span class="nc" id="L557">        return true;</span>
    }

    /**
     * Checks if the channels of this switch support
     * 'smart on'. Smart on is the ability to turn on a channel
     * such that only 1-Wire device on this channel are awake
     * and ready to do an operation.  This greatly reduces
     * the time to discover the device down a branch.
     * If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;setLatchState(int,boolean,boolean,byte[])&lt;/code&gt;
     * can be used with the &lt;code&gt;doSmart&lt;/code&gt; parameter &lt;code&gt;true&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channels support 'smart on'
     *
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean hasSmartOn() {
<span class="nc" id="L576">        return false;</span>
    }

    /**
     * Checks if the channels of this switch require that only one
     * channel is on at any one time.  If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;setLatchState(int,boolean,boolean,byte[])&lt;/code&gt;
     * will not only affect the state of the given
     * channel but may affect the state of the other channels as well
     * to insure that only one channel is on at a time.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if only one channel can be on at a time.
     *
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean onlySingleChannelOn() {
<span class="nc" id="L593">        return false;</span>
    }

    //--------
    //-------- Switch 'get' Methods
    //--------

    /**
     * Checks the sensed level on the indicated channel.
     * To avoid an exception, verify that this switch
     * has level sensing with the  &lt;code&gt;hasLevelSensing()&lt;/code&gt;.
     * Level sensing means that the device can sense the logic
     * level on its PIO pin.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if level sensed is 'high' and &lt;code&gt;false&lt;/code&gt; if level sensed is 'low'
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #hasLevelSensing()
     */
    @Override
    public boolean getLevel(int channel, byte[] state) {
     
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (channel == 0) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            return ((state [0] &amp; 0x04) == 0x04);</span>
        } else {
<span class="nc bnc" id="L621" title="All 2 branches missed.">            return ((state [0] &amp; 0x08) == 0x08);</span>
        }
    }

    /**
     * Checks the latch state of the indicated channel.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channel latch is 'on'
     * or conducting and &lt;code&gt;false&lt;/code&gt; if channel latch is 'off' and not
     * conducting.  Note that the actual output when the latch is 'on'
     * is returned from the &lt;code&gt;isHighSideSwitch()&lt;/code&gt; method.
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #isHighSideSwitch()
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean getLatchState(int channel, byte[] state) {

<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (channel == 0) {</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            return ((state[1] &amp; 0x20) != 0x20);</span>
        } else {
<span class="nc bnc" id="L646" title="All 2 branches missed.">            return ((state[1] &amp; 0x40) != 0x40);</span>
        }
    }

    /**
     * Checks if the indicated channel has experienced activity.
     * This occurs when the level on the PIO pins changes.  To clear
     * the activity that is reported, call &lt;code&gt;clearActivity()&lt;/code&gt;.
     * To avoid an exception, verify that this device supports activity
     * sensing by calling the method &lt;code&gt;hasActivitySensing()&lt;/code&gt;.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if activity was detected and &lt;code&gt;false&lt;/code&gt; if no activity was detected
     *
     * @see #hasActivitySensing()
     * @see #clearActivity()
     */
    @Override
    public boolean getSensedActivity(int channel, byte[] state) {
<span class="nc bnc" id="L667" title="All 2 branches missed.">        if (channel == 0) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            return ((state[0] &amp; 0x10) == 0x10);</span>
        } else {
<span class="nc bnc" id="L670" title="All 2 branches missed.">            return ((state[0] &amp; 0x20) == 0x20);</span>
        }
    }

    /**
     * &lt;p&gt;Clears the activity latches the next time possible.  For
     * example, on a DS2406/07, this happens the next time the
     * status is read with &lt;code&gt;readDevice()&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The activity latches will only be cleared once.  With the
     * DS2406/07, this means that only the first call to 
     * &lt;code&gt;readDevice()&lt;/code&gt; will clear the activity latches.  
     * Subsequent calls to &lt;code&gt;readDevice()&lt;/code&gt; will leave the
     * activity latch states intact, unless this method has been 
     * invoked since the last call to &lt;code&gt;readDevice()&lt;/code&gt;.&lt;/p&gt;
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #getSensedActivity(int,byte[])
     */
    @Override
    public synchronized void clearActivity() {
<span class="nc" id="L691">        clearactivity = true;</span>
<span class="nc" id="L692">    }</span>

    //--------
    //-------- Switch 'set' Methods
    //--------

    /**
     * Sets the latch state of the indicated channel.
     * The method &lt;code&gt;writeDevice()&lt;/code&gt; must be called to finalize
     * changes to the device.  Note that multiple 'set' methods can
     * be called before one call to &lt;code&gt;writeDevice()&lt;/code&gt;.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param latchState &lt;code&gt;true&lt;/code&gt; to set the channel latch 'on'
     *     (conducting) and &lt;code&gt;false&lt;/code&gt; to set the channel latch 'off' (not
     *     conducting).  Note that the actual output when the latch is 'on'
     *     is returned from the &lt;code&gt;isHighSideSwitch()&lt;/code&gt; method.
     * @param doSmart If latchState is 'on'/&lt;code&gt;true&lt;/code&gt; then doSmart indicates
     *                  if a 'smart on' is to be done.  To avoid an exception
     *                  check the capabilities of this device using the
     *                  &lt;code&gt;hasSmartOn()&lt;/code&gt; method.
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @see #hasSmartOn()
     * @see #getLatchState(int,byte[])
     * @see com.dalsemi.onewire.container.OneWireSensor#writeDevice(byte[])
     */
    @Override
    public void setLatchState(int channel, boolean latchState, boolean doSmart,
            byte[] state) {
<span class="nc bnc" id="L722" title="All 2 branches missed.">        if (channel == 0) {</span>
<span class="nc" id="L723">            state[1] &amp;= (byte) 0xdf;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (!latchState) {</span>
<span class="nc" id="L725">                state[1] = (byte) (state[1] | 0x20);</span>
            }
        } else {
<span class="nc" id="L728">            state[1] &amp;= (byte) 0xbf;</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            if (!latchState) {</span>
<span class="nc" id="L730">                state[1] = (byte) (state[1] | 0x40);</span>
            }
        }
<span class="nc" id="L733">    }</span>

    /**
     * Retrieves the 1-Wire device sensor state.  This state is
     * returned as a byte array.  Pass this byte array to the 'get'
     * and 'set' methods.  If the device state needs to be changed then call
     * the 'writeDevice' to finalize the changes.
     *
     * @return 1-Wire device sensor state
     *
     * @throws OneWireIOException on a 1-Wire communication error such as
     *         reading an incorrect CRC from a 1-Wire device.  This could be
     *         caused by a physical interruption in the 1-Wire Network due to
     *         shorts or a newly arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException on a communication or setup error with the 1-Wire
     *         adapter
     *         
     * @deprecated Use {@link #readDevice(byte[])} instead, it doesn't allocate memory.
     */
    @Override
    public synchronized byte[] readDevice() throws OneWireIOException, OneWireException {

<span class="nc" id="L755">        byte[] state = new byte [2];</span>
        
<span class="nc" id="L757">        readDevice(state);</span>

<span class="nc" id="L759">        return state;</span>
    }

    @Override
    public synchronized void readDevice(byte[] state) throws OneWireIOException, OneWireException {

        //the first byte is the raw status
        //the second byte is for writing
        //this is a strange solution because
        //the status we are interested in reading does not
        //look the same as the status we are interested in writing
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (doSpeedEnable) {</span>
<span class="nc" id="L771">            doSpeed();</span>
        }

        // select the device
<span class="nc bnc" id="L775" title="All 2 branches missed.">        if (adapter.select(address)) {</span>

            // channel access command
<span class="nc" id="L778">            buffer [0] = CHANNEL_ACCESS_COMMAND;</span>

            // send the control bytes
<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (clearactivity) {</span>
<span class="nc" id="L782">                buffer [1] = ( byte ) 0xD5;</span>
<span class="nc" id="L783">                clearactivity = false;</span>
            } else {
<span class="nc" id="L785">                buffer [1] = ( byte ) 0x55;</span>
            }

<span class="nc" id="L788">            buffer [2] = ( byte ) 0xFF;</span>

            // read the info, dummy and CRC16
<span class="nc bnc" id="L791" title="All 2 branches missed.">            for (int i = 3; i &lt; 7; i++) {</span>
<span class="nc" id="L792">                buffer [i] = ( byte ) 0xFF;</span>
            }

            // send the block
<span class="nc" id="L796">            adapter.dataBlock(buffer, 0, 7);</span>

            // calculate the CRC16 on the result and check if correct
<span class="nc bnc" id="L799" title="All 2 branches missed.">            if (CRC16.compute(buffer, 0, 7, 0) == 0xB001) {</span>
                
<span class="nc" id="L801">                state [0] = buffer [3];</span>

                //let's read the status byte 7 and get the data there
<span class="nc" id="L804">                buffer[0] = (byte)0x0aa; //READ_STATUS</span>
<span class="nc" id="L805">                buffer[1] = 7;  //address to read</span>
<span class="nc" id="L806">                buffer[2] = 0;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                for (int i=3;i&lt;6;i++)  //plus room for the CRC</span>
<span class="nc" id="L808">                    buffer[i] = (byte)0x0ff;</span>
<span class="nc" id="L809">                adapter.reset();</span>
<span class="nc" id="L810">                adapter.select(address);</span>
<span class="nc" id="L811">                adapter.dataBlock(buffer,0,6);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">                if (CRC16.compute(buffer, 0, 6, 0) == 0xB001) {</span>
<span class="nc" id="L813">                    state[1] = buffer[3];</span>
<span class="nc" id="L814">                    return;</span>
                }
            }
        }

        // device must not have been present
<span class="nc" id="L820">        throw new OneWireIOException(address, &quot;OneWireContainer12-device not present&quot;);</span>
    }

    /**
     * Writes the 1-Wire device sensor state that
     * have been changed by 'set' methods.  Only the state registers that
     * changed are updated.  This is done by referencing a field information
     * appended to the state data.
     *
     * @param  state 1-Wire device sensor state
     *
     * @throws OneWireIOException on a 1-Wire communication error such as
     *         reading an incorrect CRC from a 1-Wire device.  This could be
     *         caused by a physical interruption in the 1-Wire Network due to
     *         shorts or a newly arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException on a communication or setup error with the 1-Wire
     *         adapter
     */
    @Override
    public void writeDevice(byte[] state) throws OneWireIOException, OneWireException {
        
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if (doSpeedEnable) {</span>
<span class="nc" id="L842">            doSpeed();</span>
        }

<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (adapter.select(address)) {</span>

<span class="nc" id="L847">            synchronized (this) {</span>

                // create a block to set the switch state
                // read memory and counter command
                // write status command
<span class="nc" id="L852">                buffer [0] = WRITE_STATUS_COMMAND;</span>

                // address of switch state in status
<span class="nc" id="L855">                buffer [1] = 0x07;</span>
<span class="nc" id="L856">                buffer [2] = 0x00;</span>

                // write state
<span class="nc" id="L859">                buffer [3] = ( byte ) state [1];</span>

                // read CRC16
<span class="nc" id="L862">                buffer [4] = ( byte ) 0xFF;</span>
<span class="nc" id="L863">                buffer [5] = ( byte ) 0xFF;</span>

                // send the block
<span class="nc" id="L866">                adapter.dataBlock(buffer, 0, 6);</span>

                // calculate the CRC16 on the result and check if correct
<span class="nc bnc" id="L869" title="All 2 branches missed.">                if (CRC16.compute(buffer, 0, 6, 0) == 0xB001) {</span>
<span class="nc" id="L870">                    return;</span>
                }
<span class="nc" id="L872">            }</span>
        }

        // device must not have been present
<span class="nc" id="L876">        throw new OneWireException(address, &quot;OneWireContainer12-device not present&quot;);</span>
    }


    /**
     * Directs the container to avoid the calls to doSpeed() in methods that communicate
     * with the Thermocron. To ensure that all parts can talk to the 1-Wire bus
     * at their desired speed, each method contains a call
     * to &lt;code&gt;doSpeed()&lt;/code&gt;.  However, this is an expensive operation.
     * If a user manages the bus speed in an
     * application,  call this method with &lt;code&gt;doSpeedCheck&lt;/code&gt;
     * as &lt;code&gt;false&lt;/code&gt;.  The default behavior is
     * to call &lt;code&gt;doSpeed()&lt;/code&gt;.
     *
     * @param doSpeedCheck &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;doSpeed()&lt;/code&gt; to be called before every
     * 1-Wire bus access, &lt;code&gt;false&lt;/code&gt; to skip this expensive call
     *
     * @see OneWireContainer#doSpeed()
     */
    public synchronized void setSpeedCheck(boolean doSpeedCheck) {
<span class="nc" id="L896">        doSpeedEnable = doSpeedCheck;</span>
<span class="nc" id="L897">    }</span>

    /**
     * &lt;p&gt;Programs the Conditional Search options for the DS2406/2407.&lt;/p&gt;
     *
     * &lt;p&gt;The DS2406/2407 supports Conditional Searches with
     * user programmable search conditions.  This means that
     * the part can alarm on several kinds of conditions,
     * programmable by the user.&lt;/p&gt;
     *
     * &lt;p&gt;The user can select a channel and a source to compare to
     * a polarity.  If the source's logical value is equal to the
     * polarity, the device alarms (responds to a Conditional Search).
     * For instance, if &lt;code&gt;channel&lt;/code&gt; is &lt;code&gt;CHANNEL_A&lt;/code&gt;,
     * &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;SOURCE_ACTIVITY_LATCH&lt;/code&gt;,
     * and &lt;code&gt;polarity&lt;/code&gt; is &lt;code&gt;POLARITY_ONE&lt;/code&gt;, then the
     * device will respond to a Conditional Search when the activity
     * latch on channel A is 1 (when activity has been detected on
     * channel A).  When &lt;code&gt;channel&lt;/code&gt; is &lt;code&gt;CHANNEL_BOTH&lt;/code&gt;,
     * the selected source signals are ORed for comparison with the polarity.
     * When &lt;code&gt;channel&lt;/code&gt; is &lt;code&gt;CHANNEL_NONE&lt;/code&gt;,  the selected
     * source signal is considered a logical '0'.  In other words, if
     * &lt;code&gt;channel&lt;/code&gt; is &lt;code&gt;CHANNEL_NONE&lt;/code&gt;, if &lt;code&gt;polarity&lt;/code&gt;
     * is &lt;code&gt;POLARITY_ZERO&lt;/code&gt;, the device always responds to a
     * Conditional Search.  If &lt;code&gt;polarity&lt;/code&gt; is &lt;code&gt;POLARITY_ONE&lt;/code&gt;,
     * the device never responds to a Conditional Search.&lt;/p&gt;
     *
     * &lt;p&gt;Note that for any of these options, the value &lt;code&gt;DONT_CHANGE&lt;/code&gt;
     * will insure that the value previously used by the DS2406/2407 will
     * not be altered.&lt;/p&gt;
     *
     * &lt;p&gt;The method &lt;code&gt;writeDevice()&lt;/code&gt; must be called to finalize
     * changes to the device.  Note that multiple 'set' methods can
     * be called before one call to &lt;code&gt;writeDevice()&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;Also note that the Hidden Mode of the DS2407 is not supported in this
     * implementation as an option for source selection.  Hidden Mode was
     * phased out for the newer DS2406.  See the datasheet for the DS2407
     * for more information on Hidden Mode.&lt;/p&gt;
     *
     * @param channel the channel of interest for the source of the conditional check
     * (valid values are &lt;code&gt;CHANNEL_NONE&lt;/code&gt;, &lt;code&gt;CHANNEL_A_ONLY&lt;/code&gt;, &lt;code&gt;CHANNEL_B_ONLY&lt;/code&gt;, &lt;code&gt;CHANNEL_BOTH&lt;/code&gt;, and &lt;code&gt;DONT_CHANGE&lt;/code&gt;)
     * @param source the source selection for the conditional check
     * (valid values are &lt;code&gt;SOURCE_ACTIVITY_LATCH&lt;/code&gt;, &lt;code&gt;SOURCE_FLIP_FLOP&lt;/code&gt;, &lt;code&gt;SOURCE_PIO&lt;/code&gt;, and &lt;code&gt;DONT_CHANGE&lt;/code&gt;)
     * @param polarity the polarity selection for the conditional check
     * (valid values are &lt;code&gt;POLARITY_ZERO&lt;/code&gt;, &lt;code&gt;POLARITY_ONE&lt;/code&gt;, and &lt;code&gt;DONT_CHANGE&lt;/code&gt;)
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see com.dalsemi.onewire.container.OneWireSensor#writeDevice(byte[])
     * @see #CHANNEL_NONE
     * @see #CHANNEL_A_ONLY
     * @see #CHANNEL_B_ONLY
     * @see #CHANNEL_BOTH
     * @see #SOURCE_ACTIVITY_LATCH
     * @see #SOURCE_PIO
     * @see #SOURCE_FLIP_FLOP
     * @see #POLARITY_ONE
     * @see #POLARITY_ZERO
     * @see #DONT_CHANGE
     */
    public void setSearchConditions(byte channel, byte source, byte polarity, byte[] state) {
        
        //state[1] bitmap
        // SUP PIOB PIOA CSS4 CSS3 CSS2 CSS1  CSS0
        //               [channel] [source ][polarity]
        //so channel needs to be shifted left once, other's can be or-ed in
<span class="nc" id="L964">        byte newstate = 0;</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">        if (channel != DONT_CHANGE) {</span>
<span class="nc" id="L966">            newstate = (byte)(channel &lt;&lt; 1);</span>
        }
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (source != DONT_CHANGE) {</span>
<span class="nc" id="L969">            newstate |= source;</span>
        }
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (polarity != DONT_CHANGE) {</span>
<span class="nc" id="L972">            newstate |= polarity;</span>
        }
<span class="nc" id="L974">        state[1] = (byte) (state[1] &amp; 0xe0);</span>
<span class="nc" id="L975">        state[1] |= newstate;</span>

<span class="nc" id="L977">    }</span>


    /**
     * &lt;p&gt;Accesses the PIO channels to sense the logical status of
     * the output node.  This method supports all the modes of
     * communication with the part as described in the datasheet for
     * the DS2406/2407.&lt;/p&gt;
     *
     * @param inbuffer The input buffer.  Depending on the other options chosen
     * to this method, this will contain data to be written to
     * the channels or it will hold space for data that will be read.
     *
     * @param toggleRW By selecting &lt;code&gt;toggleRW&lt;/code&gt; to be
     * &lt;code&gt;true&lt;/code&gt;, the part will alternately
     * read and write bytes from and to this channel.  Setting
     * &lt;code&gt;toggleRW&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; means
     * that only one operation will occur, whichever operation
     * is selected by &lt;code&gt;readInitially&lt;/code&gt;. &lt;br&gt; &lt;i&gt; &lt;b&gt; NOTE: &lt;/b&gt; 
     * When toggleRW is &lt;code&gt;true&lt;/code&gt; the 'read' bytes are
     * automatically provided and only the results of the read
     * bytes are returned. &lt;/i&gt;
     *
     * @param readInitially If &lt;code&gt;readInitially&lt;/code&gt; is
     * &lt;code&gt;true&lt;/code&gt;, the first operation to occur will
     * be a read, else it will be a write.  If &lt;code&gt;toggleRW&lt;/code&gt;
     * is &lt;code&gt;false&lt;/code&gt;, the operation chosen by this flag
     * is the only operation that will occur.  If &lt;code&gt;toggleRW&lt;/code&gt;
     * is &lt;code&gt;true&lt;/code&gt;, this operation is the one
     * that will occur first, then the other will occur.  For example,
     * if &lt;code&gt;toggleRW&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
     * &lt;code&gt;readInitially&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (and you only
     * have one channel communication), 8 bits will be written to channel
     * A and then 8 bits will be read from channel A.
     *
     * @param CRCMode The 2406/7 supports 4 CRC generation modes for error detection
     * when performing channel access.  This argument should have one
     * of the following values:
     * &lt;pre&gt;&lt;code&gt;
     *     CRC_DISABLE        Never generate a CRC
     *     CRC_EVERY_BYTE     Generate a CRC after every byte transmission.
     *     CRC_EVERY_8_BYTES  Generate a CRC after every 8 bytes.
     *     CRC_EVERY_32_BYTES Generate a CRC after every 32 bytes.
     * &lt;/code&gt;&lt;/pre&gt;
     * Invalid values will be masked to valid values.  The CRC is 16 bits,
     * and does not get passed back with the output.  This method returns
     * &lt;code&gt;null&lt;/code&gt; on a CRC failure.
     *
     * @param channelMode The 2406/7 supports 3 modes of channel communication.  This
     * argument should take one of the following values:
     * &lt;pre&gt;&lt;code&gt;
     *     CHANNEL_A_ONLY  Only communicate with PIO A
     *     CHANNEL_B_ONLY  Only communicate with PIO B
     *     CHANNEL_BOTH    Communicate with both PIO's
     * &lt;/code&gt;&lt;/pre&gt;
     * If &lt;code&gt;CHANNEL_BOTH&lt;/code&gt; is selected, data is written and read
     * from the input buffer to the two channels.
     * See the datasheet for a description of operation in this
     * mode.  If communicating with both channels, it is up to the
     * caller to format the data correctly in the input buffer
     * so the correct channel gets the correct data.  Similarly,
     * any return data must be parsed by the user.
     *
     * @param clearActivity &lt;code&gt;true&lt;/code&gt; to reset the activity latch
     *
     * @param interleave The value for the Interleave Control bit.
     * If &lt;code&gt;true&lt;/code&gt;, operates in synchronous mode.
     * If &lt;code&gt;false&lt;/code&gt;, operates in asynchronous mode.
     * See the datasheet for a discussion of asynchronous and
     * synchronous mode.  This argument only matters if communicating
     * with both channels.
     *
     * @return If any bytes were read, this returns a byte array of data
     * read from the channel access.  If no bytes were read, it
     * will return the input buffer that was to be written.  
     *
     * @throws OneWireIOException on a 1-Wire communication error such as
     *         reading an incorrect CRC from a 1-Wire device.  This could be
     *         caused by a physical interruption in the 1-Wire Network due to
     *         shorts or a newly arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException on a communication or setup error with the 1-Wire
     *         adapter
     *
     * @see #CHANNEL_A_ONLY
     * @see #CHANNEL_B_ONLY
     * @see #CHANNEL_BOTH
     * @see #CRC_DISABLE
     * @see #CRC_EVERY_BYTE
     * @see #CRC_EVERY_8_BYTES
     * @see #CRC_EVERY_32_BYTES
     */
    public byte[] channelAccess(byte[] inbuffer, boolean toggleRW,
            boolean readInitially, int CRCMode, int channelMode,
            boolean clearActivity, boolean interleave) throws OneWireException,
            OneWireIOException {

<span class="nc" id="L1073">        CRCMode     = CRCMode &amp; 0x03;       //MASK THIS TO ACCEPTABLE VALUE</span>
<span class="nc" id="L1074">        channelMode = channelMode &amp; 0x0c;   //MASK THIS TO ACCEPTABLE VALUE</span>

<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if (channelMode == 0) {</span>
<span class="nc" id="L1077">            channelMode = 0x04;   //CHANNELMODE CANNOT BE 0</span>
        }

<span class="nc bnc" id="L1080" title="All 4 branches missed.">        if (interleave &amp;&amp; (channelMode != CHANNEL_BOTH)) {</span>
            //CANNOT INTERLEAVE WITH ONLY 1 CHANNEL
<span class="nc" id="L1082">            interleave = false;</span>
        }

<span class="nc bnc" id="L1085" title="All 2 branches missed.">        if (doSpeedEnable) {</span>
<span class="nc" id="L1086">            doSpeed();</span>
        }

<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (adapter.select(address)) {</span>

            int crc16;
            int i;

            //now figure out how many bytes my output buffer needs to be
<span class="nc" id="L1095">            int inlength = inbuffer.length;</span>

<span class="nc bnc" id="L1097" title="All 2 branches missed.">            if (toggleRW) {</span>
<span class="nc" id="L1098">                inlength = (inlength &lt;&lt; 1);   //= inlength * 2</span>
            }

<span class="nc bnc" id="L1101" title="All 4 branches missed.">            switch (CRCMode) {</span>

            case CRC_EVERY_BYTE: // we need to allow for 2 CRC bytes for every
                                 // byte of the length
<span class="nc" id="L1105">                inlength = inlength * 3; // length + 2*length</span>
<span class="nc" id="L1106">                break;</span>
            case CRC_EVERY_8_BYTES: // we need to allow for 2 CRC bytes for
                                    // every 8 bytes of length
<span class="nc" id="L1109">                inlength = inlength + ((inlength &gt;&gt; 3) &lt;&lt; 1); // (length DIV 8)</span>
                                                              // * 2
<span class="nc" id="L1111">                break;</span>
            case CRC_EVERY_32_BYTES: // we need to allow for 2 CRC bytes for
                                     // every 32 bytes of length
<span class="nc" id="L1114">                inlength = inlength + ((inlength &gt;&gt; 5) &lt;&lt; 1); // (length DIV 32)</span>
                                                              // * 2
                break;
            }

<span class="nc" id="L1119">            byte[] outputbuffer = new byte [inlength + 3 + 1];   //3 control bytes + 1 information byte</span>

<span class="nc" id="L1121">            outputbuffer [0] = CHANNEL_ACCESS_COMMAND;</span>
<span class="nc" id="L1122">            crc16            = CRC16.compute(CHANNEL_ACCESS_COMMAND &amp; 0x0FF);</span>

            // send the control bytes
<span class="nc" id="L1125">            outputbuffer [1] = ( byte ) (CRCMode | channelMode</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                    | (clearActivity ? 0x80</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                            : 0x00) | (interleave</span>
<span class="nc" id="L1128">                                    ? 0x10</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">                                            : 0x00) | (toggleRW</span>
<span class="nc" id="L1130">                                                    ? 0x20</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                                                            : 0x00) | (readInitially</span>
<span class="nc" id="L1132">                                                                    ? 0x40</span>
<span class="nc" id="L1133">                                                                            : 0x00));</span>
<span class="nc" id="L1134">            outputbuffer [2] = ( byte ) 0xFF;</span>
<span class="nc" id="L1135">            crc16            = CRC16.compute(outputbuffer, 1, 2, crc16);</span>

<span class="nc bnc" id="L1137" title="All 2 branches missed.">            for (i = 3; i &lt; outputbuffer.length; i++) {</span>
<span class="nc" id="L1138">                outputbuffer [i] = ( byte ) 0xff;</span>
            }

            //now for the hard part: putting the right outputbuffer into the array
            //first lets see if we can skip this stage, ie on just a read

            /*
                At this point we have 16 options:
                Initial  Toggle  CRC   Description
             0   write    off     0    Only write these bytes, CRC disabled
             1   write    off     1    Write these bytes, CRC for every byte
             2   write    off     8    Write these bytes, CRC for every 8 bytes
             3   write    off     32   Write these bytes, CRC for every 32 bytes
             4   write    on      0    Write a byte, read a byte, no CRC
             5   write    on      1    Write a byte, CRC, read a byte, CRC
             6   write    on      8    Write a byte, read a byte X 4 then a CRC
             7   write    on      32   Write a byte, read a byte X 16 then a CRC
             8   read     off     0    Read this many bytes, CRC disabled
             9   read     off     1    Read this many bytes, CRC for every byte
             a   read     off     8    Read this many bytes, CRC for every 8 bytes
             b   read     off     32   Read this many bytes, CRC for every 32 bytes
             c   read     on      0    Read a byte, write a byte, no CRC
             d   read     on      1    Read a byte, CRC, write a byte, CRC
             e   read     on      8    Read a byte, write a byte X 4 then a CRC
             f   read     on      32   Read a byte, write a byte X 16 then a CRC

             Options 0-3 require that we space the input buffer for the CRCs.
             Options 8-b require no extra work, since we have already loaded the buffer with FF's for reads.
             Options 4 and c require that we interleave the write bytes and the read FF's
             Options 5 and d require that we interleace write byte, CRC space, read byte, CRC space
             Other options are really messy

             ...Brain
             */
<span class="nc" id="L1172">            int j      = 4;   //outputbuffer 0-2 is command bytes, outputbuffer[3] is return info</span>
<span class="nc" id="L1173">            int option = outputbuffer [1] &amp; 0x63;   //get the bits out we want for toggle, initial, and CRC</span>

<span class="nc" id="L1175">            option = ((option &gt;&gt; 3) | option) &amp; 0x0f;   //now lets make it a number 0-15</span>

            /*switch (option)
         {
             case 0    :
             case 1    :
             case 2    :
             case 3    : for (i=0;i&lt;inbuffer.length;i++)
                         {
                            outputbuffer[j] = inbuffer[i];
                            j = j + fixJ(i+1,option);
                         }
                         break;
             case 4    :
             case 5    :
             case 6    :
             case 7    : for (i=0;i&lt;inbuffer.length;i++)
                         {
                             outputbuffer[j] = inbuffer[i];
                             j = j + fixJ((i*2)+1,option);
                             //then we plug in a read space
                             j = j + fixJ((i*2)+2,option);
                         }
                         break;
             case 8    :
             case 9    :
             case 0x0a :
             case 0x0b :
                         break;  //nothing needs to be done
             case 0x0c :
             case 0x0d :
             case 0x0e :
             case 0x0f : for (i=0;i&lt;inbuffer.length;i++)
                         {
                             //first we plug in a read space
                             j = j + fixJ((i*2)+1,option);
                             outputbuffer[j] = inbuffer[i];
                             j = j + fixJ((i*2)+2,option);
                         }
                         break;
         }*/

            /* this next section of code replaces the previous section to reduce redundant code.
            here we are formatting the output buffer so it has FF's in the right places
            for reading the CRC's and reading the data from the channels.  the previous code
            is left because it makes a little more sense in that form. at least i think so.

            ...Pinky
             */
<span class="nc bnc" id="L1224" title="All 4 branches missed.">            if ((option &lt; 8) || (option &gt; 0x0b))   //if this is not a read-only (which we need do nothing for)</span>
            {
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                for (i = 0; i &lt; inbuffer.length; i++)</span>
                {
<span class="nc bnc" id="L1228" title="All 2 branches missed.">                    if (option &gt; 0x0b)   //then we are reading first</span>
<span class="nc" id="L1229">                        j = j + fixJ((i * 2) + 1, option);   //  leave a space for a read, and the CRC if need be</span>

<span class="nc" id="L1231">                    outputbuffer [j] = inbuffer [i];   //write this data</span>

<span class="nc bnc" id="L1233" title="All 2 branches missed.">                    if (option &lt; 0x04)      //if this is only a write</span>
<span class="nc" id="L1234">                        j = j + fixJ(i + 1, option);   //  leave a space for CRC if needed, else just increment</span>
                    else                    //else we are toggling
                    {
<span class="nc bnc" id="L1237" title="All 2 branches missed.">                        if (option &lt; 0x08)   //this is a write-first toggle</span>
<span class="nc" id="L1238">                            j = j + fixJ((i * 2) + 1, option);   //   so leave a space for a read</span>

<span class="nc" id="L1240">                        j = j + fixJ((i * 2) + 2, option);   //now leave a space for the CRC</span>
                    }
                }
            }

            // now our output buffer should be set correctly
            // send the block Pinky!
<span class="nc" id="L1247">            adapter.dataBlock(outputbuffer, 0, outputbuffer.length);</span>

            // calculate the CRC16 within the resulting buffer for integrity
            //start at offset 3 for the information byte
<span class="nc" id="L1251">            crc16 = CRC16.compute(outputbuffer [3], crc16);</span>
<span class="nc" id="L1252">            j     = 0;   //j will be how many bytes we are into the buffer - CRC bytes read</span>

<span class="nc" id="L1254">            int     k            = 0;   //index into the return buffer</span>
<span class="nc" id="L1255">            boolean fresh        = false;   //whether or not we need to reinitialize the CRC calculation</span>
<span class="nc" id="L1256">            byte[]  returnbuffer = new byte [inbuffer.length];</span>

<span class="nc bnc" id="L1258" title="All 2 branches missed.">            for (i = 4; i &lt; outputbuffer.length; i++) {</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                if (CRCMode != CRC_DISABLE) {</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">                    if (fresh) {</span>
<span class="nc" id="L1261">                        crc16 = CRC16.compute(outputbuffer [i]);</span>
<span class="nc" id="L1262">                        fresh = false;</span>
                    } else {
<span class="nc" id="L1264">                        crc16 = CRC16.compute(outputbuffer [i], crc16);</span>
                    }
                }

<span class="nc bnc" id="L1268" title="All 16 branches missed.">                if ((!toggleRW &amp;&amp; readInitially)</span>
                        || (toggleRW &amp;&amp; readInitially &amp;&amp; ((j &amp; 0x01) == 0x00))
                        || (toggleRW &amp;&amp;!readInitially &amp;&amp; ((j &amp; 0x01) == 0x01))) {
<span class="nc" id="L1271">                    returnbuffer [k] = outputbuffer [i];</span>

<span class="nc" id="L1273">                    k++;</span>
                }

<span class="nc" id="L1276">                j++;</span>

<span class="nc bnc" id="L1278" title="All 4 branches missed.">                if ((fixJ(j, option) &gt; 1) &amp;&amp; (CRCMode != CRC_DISABLE))   //means that we should look for a CRC</span>
                {
<span class="nc" id="L1280">                    crc16 = CRC16.compute(outputbuffer, i + 1, 2, crc16);</span>
<span class="nc" id="L1281">                    i     += 2;</span>

<span class="nc bnc" id="L1283" title="All 2 branches missed.">                    if (crc16 != 0xb001)</span>
<span class="nc" id="L1284">                        throw new OneWireIOException(address, &quot;Invalid CRC&quot;);</span>

<span class="nc" id="L1286">                    fresh = true;</span>
                }
            }

            //now that we got the right bytes out of the array
<span class="nc" id="L1291">            return returnbuffer;</span>
        }

        // device must not have been present
<span class="nc" id="L1295">        throw new OneWireIOException(address, &quot;OneWireContainer12-device not present&quot;);</span>
    }

    //--------
    //-------- Private
    //--------

    /*
     * This method returns how much we should increment the index variable into
     * our output buffer.  should be called after every setting of a value.
     *
     * @param current_index  current index into the channel access array
     * @param option_mask    contains data on CRC generation
     *
     * @return amount to increment the index variable
     */
    private int fixJ(int current_index, int option_mask) {

        //assume that current_index started at 0, but this function is never called at 0
<span class="nc bnc" id="L1314" title="All 3 branches missed.">        switch (option_mask &amp; 0x03) {</span>

        case 0x00:
<span class="nc" id="L1317">            return 1; // no crc</span>
        case 0x01:
<span class="nc" id="L1319">            return 3; // 2-byte CRC after every byte</span>
        default: // must be 0x02 (after 8 bytes) or 0x03 (after 32 bytes)
<span class="nc bnc" id="L1321" title="All 2 branches missed.">            if ((current_index &amp; (8 + (24 * (option_mask &amp; 0x01)) - 1)) == 0) {</span>
<span class="nc" id="L1322">                return 3;</span>
            }

            /* OK let me explain that last piece of code:
            The only return values are going to be 1 and 3, 1 for a normal increment
            and 3 if we want to leave space to recieve a CRC.

            So the mask gets the bits out that are concerned with the CRC.  When its 0 it
            means that the CRC is disabled, so the next location into our destination
            array we need to copy into is just the next available location.

            When it is 1, it means we will recieve a CRC after each transmission, so
            we should leave a 2 byte space for it (thus increament by 3).

            When it is 2, it means that after every 8 bytes we want to recieve a CRC
            byte pair.  When it is a 3, it means that every 32 bytes we want the CRC
            pair.  So what we want to check is if the current_index is divisible by 8
            or 32 (we do not call this method with current_index==0).  Since 8 and 32
            are powers of 2 we do it with the '&amp;' operator and 7 or 31 as the other
            value (2^n - 1).  The (8+(24 * option_mask&amp;0x01)) bit just returns me 8
            or 32.
             */
        }

<span class="nc" id="L1346">        return 1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>