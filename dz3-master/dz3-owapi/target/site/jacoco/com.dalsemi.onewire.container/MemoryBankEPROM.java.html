<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MemoryBankEPROM.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OWAPI 1.00 refactored for DIY Zoning</a> &gt; <a href="index.source.html" class="el_package">com.dalsemi.onewire.container</a> &gt; <span class="el_source">MemoryBankEPROM.java</span></div><h1>MemoryBankEPROM.java</h1><pre class="source lang-java linenums">
/*---------------------------------------------------------------------------
 * Copyright (C) 1999,2000 Dallas Semiconductor Corporation, All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL DALLAS SEMICONDUCTOR BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Dallas Semiconductor
 * shall not be used except as stated in the Dallas Semiconductor
 * Branding Policy.
 *---------------------------------------------------------------------------
 */

package com.dalsemi.onewire.container;

// imports
import com.dalsemi.onewire.OneWireException;
import com.dalsemi.onewire.adapter.*;
import com.dalsemi.onewire.utils.*;
import com.dalsemi.onewire.container.OneWireContainer;


/**
 * Memory bank class for the EPROM section of iButtons and 1-Wire devices.
 *
 *  @version    0.00, 28 Aug 2000
 *  @author     DS
 * @author Stability enhancements &amp;copy; &lt;a href=&quot;mailto:vt@freehold.crocodile.org&quot;&gt; Vadim Tkachenko&lt;/a&gt; 2001-2009
 */
class MemoryBankEPROM implements OTPMemoryBank {

    //--------
    //-------- Static Final Variables
    //--------

    /**
     * Read Memory Command
     */
    public static final byte READ_MEMORY_COMMAND = (byte) 0xF0;

    /**
     * Main memory read command
     */
    public static final byte MAIN_READ_PAGE_COMMAND = (byte) 0xA5;

    /**
     * Status memory read command
     */
    public static final byte STATUS_READ_PAGE_COMMAND = (byte) 0xAA;

    /**
     * Main memory write command
     */
    public static final byte MAIN_WRITE_COMMAND = (byte) 0x0F;

    /**
     * Status memory write command
     */
    public static final byte STATUS_WRITE_COMMAND = (byte) 0x55;

    //--------
    //-------- Variables
    //--------

    /**
     * Reference to the OneWireContainer this bank resides on.
     */
    protected OneWireContainer ib;

    /**
     * Read page with CRC command
     */
    protected byte READ_PAGE_WITH_CRC;

    /**
     * Number of CRC bytes (1-2)
     */
    protected int numCRCBytes;

    /**
     * Get crc after sending command,address
     */
    protected boolean crcAfterAddress;

    /**
     * Get crc during a normal read
     */
    protected boolean normalReadCRC;

    /**
     * Program Memory Command
     */
    protected byte WRITE_MEMORY_COMMAND;

    /**
     * block of 0xFF's used for faster read pre-fill of 1-Wire blocks
     */
    protected byte[] ffBlock;

    /**
     * Flag to indicate that speed needs to be set
     */
    protected boolean doSetSpeed;

    //--------
    //-------- Protected Variables for MemoryBank implementation 
    //--------

    /**
     * Size of memory bank in bytes
     */
    protected int size;

    /**
     * Memory bank descriptions
     */
    protected String bankDescription;

    /**
     * Memory bank usage flags
     */
    protected boolean generalPurposeMemory;

    /**
     * Flag if memory bank is read/write
     */
    protected boolean readWrite;

    /**
     * Flag if memory bank is write once (EPROM)
     */
    protected boolean writeOnce;

    /**
     * Flag if memory bank is read only
     */
    protected boolean readOnly;

    /**
     * Flag if memory bank is non volatile (will not erase when power removed)
     */
    protected boolean nonVolatile;

    /**
     * Flag if memory bank needs program Pulse to write
     */
    protected boolean programPulse;

    /**
     * Flag if memory bank needs power delivery to write
     */
    protected boolean powerDelivery;

    /**
     * Starting physical address in memory bank. Needed for different types of
     * memory in the same logical memory bank. This can be used to seperate them
     * into two virtual memory banks. Example: DS2406 status page has mixed
     * EPROM and Volatile RAM.
     */
    protected int startPhysicalAddress;

    /**
     * Flag if read back verification is enabled in 'write()'.
     */
    protected boolean writeVerification;

    //--------
    //-------- Protected Variables for PagedMemoryBank implementation 
    //--------

    /**
     * Number of pages in memory bank
     */
    protected int numberPages;

    /**
     * page length in memory bank
     */
    protected int pageLength;

    /**
     * Max data length in page packet in memory bank
     */
    protected int maxPacketDataLength;

    /**
     * Flag if memory bank has page auto-CRC generation
     */
    protected boolean pageAutoCRC;

    /**
     * Flag if reading a page in memory bank provides optional extra information
     * (counter, tamper protection, SHA-1...)
     */
    protected boolean extraInfo;

    /**
     * Length of extra information when reading a page in memory bank
     */
    protected int extraInfoLength;

    /**
     * Extra information description when reading page in memory bank
     */
    protected String extraInfoDescription;

    //--------
    //-------- Protected Variables for OTPMemoryBank implementation 
    //--------

    /**
     * Flag if memory bank can have pages redirected
     */
    protected boolean redirectPage;

    /**
     * Flag if memory bank can have pages locked
     */
    protected boolean lockPage;

    /**
     * Flag if memory bank can have pages locked from redirected
     */
    protected boolean lockRedirectPage;

    /**
     * Memory bank to lock pages in 'this' memory bank
     */
    protected PagedMemoryBank mbLock;

    /**
     * Memory bank to redirect pages in 'this' memory bank
     */
    protected PagedMemoryBank mbRedirect;

    /**
     * Memory bank to lock redirect bytes in 'this' memory bank
     */
    protected PagedMemoryBank mbLockRedirect;

    /**
     * Byte offset into memory bank 'mbLock' to indicate where page 0 can be
     * locked
     */
    protected int lockOffset;

    /**
     * Byte offset into memory bank 'mbRedirect' to indicate where page 0 can be
     * redirected
     */
    protected int redirectOffset;

    /**
     * Byte offset into memory bank 'mbLockRedirect' to indicate where page 0
     * can have its redirection byte locked
     */
    protected int lockRedirectOffset;

    //--------
    //-------- Constructor
    //--------

    /**
     * Memory bank contstuctor.  Requires reference to the OneWireContainer
     * this memory bank resides on.  Requires reference to memory banks used
     * in OTP operations.
     */
<span class="nc" id="L283">    public MemoryBankEPROM(OneWireContainer ibutton) {</span>

        // keep reference to ibutton where memory bank is
<span class="nc" id="L286">        ib = ibutton;</span>

        // get references to MemoryBanks used in OTP operations, assume no locking/redirection
<span class="nc" id="L289">        mbLock             = null;</span>
<span class="nc" id="L290">        mbRedirect         = null;</span>
<span class="nc" id="L291">        mbLockRedirect     = null;</span>
<span class="nc" id="L292">        lockOffset         = 0;</span>
<span class="nc" id="L293">        redirectOffset     = 0;</span>
<span class="nc" id="L294">        lockRedirectOffset = 0;</span>

        // initialize attributes of this memory bank - DEFAULT: Main memory DS1985 w/o lock stuff
<span class="nc" id="L297">        generalPurposeMemory = true;</span>
<span class="nc" id="L298">        bankDescription      = &quot;Main Memory&quot;;</span>
<span class="nc" id="L299">        numberPages          = 64;</span>
<span class="nc" id="L300">        size                 = 2048;</span>
<span class="nc" id="L301">        pageLength           = 32;</span>
<span class="nc" id="L302">        maxPacketDataLength  = 29;</span>
<span class="nc" id="L303">        readWrite            = false;</span>
<span class="nc" id="L304">        writeOnce            = true;</span>
<span class="nc" id="L305">        readOnly             = false;</span>
<span class="nc" id="L306">        nonVolatile          = true;</span>
<span class="nc" id="L307">        pageAutoCRC          = true;</span>
<span class="nc" id="L308">        redirectPage         = false;</span>
<span class="nc" id="L309">        lockPage             = false;</span>
<span class="nc" id="L310">        lockRedirectPage     = false;</span>
<span class="nc" id="L311">        programPulse         = true;</span>
<span class="nc" id="L312">        powerDelivery        = false;</span>
<span class="nc" id="L313">        extraInfo            = true;</span>
<span class="nc" id="L314">        extraInfoLength      = 1;</span>
<span class="nc" id="L315">        extraInfoDescription = &quot;Inverted redirection page&quot;;</span>
<span class="nc" id="L316">        writeVerification    = true;</span>
<span class="nc" id="L317">        startPhysicalAddress = 0;</span>
<span class="nc" id="L318">        READ_PAGE_WITH_CRC   = MAIN_READ_PAGE_COMMAND;</span>
<span class="nc" id="L319">        WRITE_MEMORY_COMMAND = MAIN_WRITE_COMMAND;</span>
<span class="nc" id="L320">        numCRCBytes          = 2;</span>
<span class="nc" id="L321">        crcAfterAddress      = true;</span>
<span class="nc" id="L322">        normalReadCRC        = false;</span>
<span class="nc" id="L323">        doSetSpeed           = true;</span>

        // create the ffblock (used for faster 0xFF fills)
<span class="nc" id="L326">        ffBlock = new byte[50];</span>

<span class="nc bnc" id="L328" title="All 2 branches missed.">        for (int i = 0; i &lt; 50; i++) {</span>
<span class="nc" id="L329">            ffBlock[i] = (byte) 0xFF;</span>
        }
<span class="nc" id="L331">    }</span>

    //--------
    //-------- MemoryBank query methods
    //--------

    /**
     * Query to see get a string description of the current memory bank.
     *
     * @return  String containing the memory bank description
     */
    @Override
    public String getBankDescription() {
<span class="nc" id="L344">        return bankDescription;</span>
    }

    /**
     * Query to see if the current memory bank is general purpose
     * user memory.  If it is NOT then it is Memory-Mapped and writing
     * values to this memory will affect the behavior of the 1-Wire
     * device.
     *
     * @return  'true' if current memory bank is general purpose
     */
    @Override
    public boolean isGeneralPurposeMemory() {
<span class="nc" id="L357">        return generalPurposeMemory;</span>
    }

    /**
     * Query to see if current memory bank is read/write.
     *
     * @return  'true' if current memory bank is read/write
     */
    @Override
    public boolean isReadWrite() {
<span class="nc" id="L367">        return readWrite;</span>
    }

    /**
     * Query to see if current memory bank is write write once such
     * as with EPROM technology.
     *
     * @return  'true' if current memory bank can only be written once
     */
    @Override
    public boolean isWriteOnce() {
<span class="nc" id="L378">        return writeOnce;</span>
    }

    /**
     * Query to see if current memory bank is read only.
     *
     * @return  'true' if current memory bank can only be read
     */
    @Override
    public boolean isReadOnly() {
<span class="nc" id="L388">        return readOnly;</span>
    }

    /**
     * Query to see if current memory bank non-volatile.  Memory is
     * non-volatile if it retains its contents even when removed from
     * the 1-Wire network.
     *
     * @return  'true' if current memory bank non volatile.
     */
    @Override
    public boolean isNonVolatile() {
<span class="nc" id="L400">        return nonVolatile;</span>
    }

    /**
     * Query to see if current memory bank pages need the adapter to
     * have a 'ProgramPulse' in order to write to the memory.
     *
     * @return  'true' if writing to the current memory bank pages
     *                 requires a 'ProgramPulse'.
     */
    @Override
    public boolean needsProgramPulse() {
<span class="nc" id="L412">        return programPulse;</span>
    }

    /**
     * Query to see if current memory bank pages need the adapter to
     * have a 'PowerDelivery' feature in order to write to the memory.
     *
     * @return  'true' if writing to the current memory bank pages
     *                 requires 'PowerDelivery'.
     */
    @Override
    public boolean needsPowerDelivery() {
<span class="nc" id="L424">        return powerDelivery;</span>
    }

    /**
     * Query to get the starting physical address of this bank.  Physical
     * banks are sometimes sub-divided into logical banks due to changes
     * in attributes.
     *
     * @return  physical starting address of this logical bank.
     */
    @Override
    public int getStartPhysicalAddress() {
<span class="nc" id="L436">        return startPhysicalAddress;</span>
    }

    /**
     * Query to get the memory bank size in bytes.
     *
     * @return  memory bank size in bytes.
     */
    @Override
    public int getSize() {
<span class="nc" id="L446">        return size;</span>
    }

    //--------
    //-------- PagedMemoryBank query methods
    //--------

    /**
     * Query to get the number of pages in current memory bank.
     *
     * @return  number of pages in current memory bank
     */
    @Override
    public int getNumberPages() {
<span class="nc" id="L460">        return numberPages;</span>
    }

    /**
     * Query to get  page length in bytes in current memory bank.
     *
     * @return   page length in bytes in current memory bank
     */
    @Override
    public int getPageLength() {
<span class="nc" id="L470">        return pageLength;</span>
    }

    /**
     * Query to get Maximum data page length in bytes for a packet
     * read or written in the current memory bank.  See the 'ReadPagePacket()'
     * and 'WritePagePacket()' methods.  This method is only usefull
     * if the current memory bank is general purpose memory.
     *
     * @return  max packet page length in bytes in current memory bank
     */
    @Override
    public int getMaxPacketDataLength() {
<span class="nc" id="L483">        return maxPacketDataLength;</span>
    }

    /**
     * Query to see if current memory bank pages can be read with
     * the contents being verified by a device generated CRC.
     * This is used to see if the 'ReadPageCRC()' can be used.
     *
     * @return  'true' if current memory bank can be read with self
     *          generated CRC.
     */
    @Override
    public boolean hasPageAutoCRC() {
<span class="nc" id="L496">        return pageAutoCRC;</span>
    }

    /**
     * Query to see if current memory bank pages when read deliver
     * extra information outside of the normal data space.  Examples
     * of this may be a redirection byte, counter, tamper protection
     * bytes, or SHA-1 result.  If this method returns true then the
     * methods 'ReadPagePacket()' and 'readPageCRC()' with 'extraInfo'
     * parameter can be used.
     *
     * @return  'true' if reading the current memory bank pages
     *                 provides extra information.
     *
     * @deprecated  As of 1-Wire API 0.01, replaced by {@link #hasExtraInfo()}
     */
    @Override
    public boolean haveExtraInfo() {
<span class="nc" id="L514">        return hasExtraInfo();</span>
    }

    /**
     * Checks to see if this memory bank's pages deliver extra 
     * information outside of the normal data space,  when read.  Examples
     * of this may be a redirection byte, counter, tamper protection
     * bytes, or SHA-1 result.  If this method returns true then the
     * methods with an 'extraInfo' parameter can be used:
     * {@link #readPage(int,boolean,byte[],int,byte[]) readPage},
     * {@link #readPageCRC(int,boolean,byte[],int,byte[]) readPageCRC}, and
     * {@link #readPagePacket(int,boolean,byte[],int,byte[]) readPagePacket}.
     *
     * @return  &lt;CODE&gt; true &lt;/CODE&gt; if reading the this memory bank's 
     *                 pages provides extra information
     *
     * @see #readPage(int,boolean,byte[],int,byte[]) readPage(extra)
     * @see #readPageCRC(int,boolean,byte[],int,byte[]) readPageCRC(extra)
     * @see #readPagePacket(int,boolean,byte[],int,byte[]) readPagePacket(extra)
     * @since 1-Wire API 0.01
     */
    @Override
    public boolean hasExtraInfo() {
<span class="nc" id="L537">        return extraInfo;</span>
    }

    /**
     * Query to get the length in bytes of extra information that
     * is read when read a page in the current memory bank.  See
     * 'hasExtraInfo()'.
     *
     * @return  number of bytes in Extra Information read when reading
     *          pages in the current memory bank.
     */
    @Override
    public int getExtraInfoLength() {
<span class="nc" id="L550">        return extraInfoLength;</span>
    }

    /**
     * Query to get a string description of what is contained in
     * the Extra Informationed return when reading pages in the current
     * memory bank.  See 'hasExtraInfo()'.
     *
     * @return string describing extra information.
     */
    @Override
    public String getExtraInfoDescription() {
<span class="nc" id="L562">        return extraInfoDescription;</span>
    }

    /**
     * Set the write verification for the 'write()' method.
     *
     * @param  doReadVerf   true (default) verify write in 'write'
     *                      false, don't verify write (used on
     *                      Write-Once bit manipulation)
     */
    @Override
    public void setWriteVerification(boolean doReadVerf) {
<span class="nc" id="L574">        writeVerification = doReadVerf;</span>
<span class="nc" id="L575">    }</span>

    //--------
    //-------- OTPMemoryBank query methods
    //--------

    /**
     * Query to see if current memory bank pages can be redirected
     * to another pages.  This is mostly used in Write-Once memory
     * to provide a means to update.
     *
     * @return  'true' if current memory bank pages can be redirected
     *          to a new page.
     */
    @Override
    public boolean canRedirectPage() {
<span class="nc" id="L591">        return redirectPage;</span>
    }

    /**
     * Query to see if current memory bank pages can be locked.  A
     * locked page would prevent any changes to the memory.
     *
     * @return  'true' if current memory bank pages can be redirected
     *          to a new page.
     */
    @Override
    public boolean canLockPage() {
<span class="nc" id="L603">        return lockPage;</span>
    }

    /**
     * Query to see if current memory bank pages can be locked from
     * being redirected.  This would prevent a Write-Once memory from
     * being updated.
     *
     * @return  'true' if current memory bank pages can be locked from
     *          being redirected to a new page.
     */
    @Override
    public boolean canLockRedirectPage() {
<span class="nc" id="L616">        return lockRedirectPage;</span>
    }

    //--------
    //-------- MemoryBank I/O methods
    //--------

    /**
     * Read  memory in the current bank with no CRC checking (device or
     * data). The resulting data from this API may or may not be what is on
     * the 1-Wire device.  It is recommends that the data contain some kind
     * of checking (CRC) like in the readPagePacket() method or have
     * the 1-Wire device provide the CRC as in readPageCRC().  readPageCRC()
     * however is not supported on all memory types, see 'hasPageAutoCRC()'.
     * If neither is an option then this method could be called more
     * then once to at least verify that the same thing is read consistantly.
     *
     * @param  startAddr     starting physical address
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       read() continious where the last one led off
     *                       and it is inside a 'beginExclusive/endExclusive'
     *                       block.
     * @param  readBuf       byte array to place read data into
     * @param  offset        offset into readBuf to place data
     * @param  len           length in bytes to read
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void read(int startAddr, boolean readContinue, byte[] readBuf,
            int offset, int len) throws OneWireIOException, OneWireException {
        int i;

        // check if read exceeds memory
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if ((startAddr + len) &gt; (pageLength * numberPages)) {</span>
<span class="nc" id="L653">            throw new OneWireException(&quot;Read exceeds memory bank end&quot;);</span>
        }

        // attempt to put device at max desired speed
<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (!readContinue) {</span>
<span class="nc" id="L658">            checkSpeed();</span>
        }

        // check if status memory
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (READ_PAGE_WITH_CRC == STATUS_READ_PAGE_COMMAND) {</span>

            // no regular read memory so must use readPageCRC
<span class="nc" id="L665">            int start_pg = startAddr / pageLength;</span>
<span class="nc" id="L666">            int end_pg   = ((startAddr + len) / pageLength) - 1;</span>

<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (((startAddr + len) % pageLength) &gt; 0) {</span>
<span class="nc" id="L669">                end_pg++;</span>
            }

<span class="nc" id="L672">            byte[] raw_buf = new byte [(end_pg - start_pg + 1) * pageLength];</span>

            // loop to read the pages
<span class="nc bnc" id="L675" title="All 2 branches missed.">            for (int pg = start_pg; pg &lt;= end_pg; pg++) {</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                readPageCRC(pg, !(pg == start_pg), raw_buf, (pg - start_pg)</span>
                        * pageLength, null, 0);
            }

            // extract out the data
<span class="nc" id="L681">            System.arraycopy(raw_buf, (startAddr % pageLength), readBuf, offset, len);</span>
<span class="nc" id="L682">        } else {</span>
            // regular memory so use standard read memory command

            // see if need to access the device
<span class="nc bnc" id="L686" title="All 2 branches missed.">            if (!readContinue) {</span>

                // select the device
<span class="nc bnc" id="L689" title="All 2 branches missed.">                if (!ib.adapter.select(ib.address)) {</span>
<span class="nc" id="L690">                    forceVerify();</span>

<span class="nc" id="L692">                    throw new OneWireIOException(&quot;Device select failed&quot;);</span>
                }

                // build start reading memory block
<span class="nc" id="L696">                byte[] raw_buf = new byte [4];</span>

<span class="nc" id="L698">                raw_buf [0] = READ_MEMORY_COMMAND;</span>
<span class="nc" id="L699">                raw_buf [1] = ( byte ) ((startAddr + startPhysicalAddress)</span>
                        &amp; 0xFF);
<span class="nc" id="L701">                raw_buf [2] =</span>
                    ( byte ) ((((startAddr + startPhysicalAddress) &amp; 0xFFFF) &gt;&gt;&gt; 8)
                            &amp; 0xFF);
<span class="nc" id="L704">                raw_buf [3] = ( byte ) 0xFF;</span>

                // check if get a 1 byte crc in a normal read.
<span class="nc bnc" id="L707" title="All 2 branches missed.">                int num_bytes = (normalReadCRC) ? 4</span>
<span class="nc" id="L708">                        : 3;</span>

                // do the first block for command, address
<span class="nc" id="L711">                ib.adapter.dataBlock(raw_buf, 0, num_bytes);</span>
            }

            // pre-fill readBuf with 0xFF 
<span class="nc" id="L715">            int pgs   = len / pageLength;</span>
<span class="nc" id="L716">            int extra = len % pageLength;</span>

<span class="nc bnc" id="L718" title="All 2 branches missed.">            for (i = 0; i &lt; pgs; i++) {</span>
<span class="nc" id="L719">                System.arraycopy(ffBlock, 0, readBuf, offset + i * pageLength, pageLength);</span>
            }
            
<span class="nc" id="L722">            System.arraycopy(ffBlock, 0, readBuf, offset + pgs * pageLength, extra);</span>

            // send second block to read data, return result
<span class="nc" id="L725">            ib.adapter.dataBlock(readBuf, offset, len);</span>
        }
<span class="nc" id="L727">    }</span>

    /**
     * Write  memory in the current bank.  It is recommended that
     * when writing  data that some structure in the data is created
     * to provide error free reading back with read().  Or the
     * method 'writePagePacket()' could be used which automatically
     * wraps the data in a length and CRC.
     *
     * When using on Write-Once devices care must be taken to write into
     * into empty space.  If write() is used to write over an unlocked
     * page on a Write-Once device it will fail.  If write verification
     * is turned off with the method 'setWriteVerification(false)' then
     * the result will be an 'AND' of the existing data and the new data.
     *
     * @param  startAddr     starting address
     * @param  writeBuf      byte array containing data to write
     * @param  offset        offset into writeBuf to get data
     * @param  len           length in bytes to write
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void write(int startAddr, byte[] writeBuf, int offset, int len) throws OneWireIOException, OneWireException {

        int  i;
        byte result;

        // return if nothing to do
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (len == 0) {</span>
<span class="nc" id="L758">            return;</span>
        }

        // check if power delivery is available
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (!ib.adapter.canProgram()) {</span>
<span class="nc" id="L763">            throw new OneWireException(</span>
            &quot;Program voltage required but not available&quot;);
        }

        // check if trying to write read only bank
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (isReadOnly()) {</span>
<span class="nc" id="L769">            throw new OneWireException(&quot;Trying to write read-only memory bank&quot;);</span>
        }

        // check if write exceeds memory
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if ((startAddr + len) &gt; (pageLength * numberPages)) {</span>
<span class="nc" id="L774">            throw new OneWireException(&quot;Write exceeds memory bank end&quot;);</span>
        }

        // set the program pulse duration
<span class="nc" id="L778">        ib.adapter.setProgramPulseDuration(DSPortAdapter.DELIVERY_EPROM);</span>

        // attempt to put device at max desired speed
<span class="nc" id="L781">        checkSpeed();</span>

        // loop while still have bytes to write
<span class="nc" id="L784">        boolean write_continue = false;</span>

<span class="nc bnc" id="L786" title="All 2 branches missed.">        for (i = 0; i &lt; len; i++) {</span>

<span class="nc" id="L788">            result = programByte(startAddr + i + startPhysicalAddress, writeBuf [offset + i], write_continue);</span>

<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (writeVerification) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (( byte ) result == ( byte ) writeBuf [offset + i]) {</span>
<span class="nc" id="L792">                    write_continue = true;</span>
                } else {
<span class="nc" id="L794">                    forceVerify();</span>

<span class="nc" id="L796">                    throw new OneWireIOException(</span>
                    &quot;Read back byte on EPROM programming did not match&quot;);
                }
            }
        }
<span class="nc" id="L801">    }</span>

    //--------
    //-------- PagedMemoryBank I/O methods
    //--------

    /**
     * Read  page in the current bank with no
     * CRC checking (device or data). The resulting data from this API
     * may or may not be what is on the 1-Wire device.  It is recommends
     * that the data contain some kind of checking (CRC) like in the
     * readPagePacket() method or have the 1-Wire device provide the
     * CRC as in readPageCRC().  readPageCRC() however is not
     * supported on all memory types, see 'hasPageAutoCRC()'.
     * If neither is an option then this method could be called more
     * then once to at least verify that the same thing is read consistantly.
     *
     * @param  page          page number to read packet from
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       readPage() continious where the last one
     *                       led off and it is inside a
     *                       'beginExclusive/endExclusive' block.
     * @param  readBuf       byte array to place read data into
     * @param  offset        offset into readBuf to place data
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void readPage(int page, boolean readContinue, byte[] readBuf, int offset) throws OneWireIOException, OneWireException {
        
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (pageAutoCRC) {</span>
<span class="nc" id="L834">            readPageCRC(page, readContinue, readBuf, offset, null, extraInfoLength);</span>
        } else {
<span class="nc" id="L836">            read(page * pageLength, readContinue, readBuf, offset, pageLength);</span>
        }
<span class="nc" id="L838">    }</span>

    /**
     * Read  page with extra information in the current bank with no
     * CRC checking (device or data). The resulting data from this API
     * may or may not be what is on the 1-Wire device.  It is recommends
     * that the data contain some kind of checking (CRC) like in the
     * readPagePacket() method or have the 1-Wire device provide the
     * CRC as in readPageCRC().  readPageCRC() however is not
     * supported on all memory types, see 'hasPageAutoCRC()'.
     * If neither is an option then this method could be called more
     * then once to at least verify that the same thing is read consistantly.
     * See the method 'hasExtraInfo()' for a description of the optional
     * extra information some devices have.
     *
     * @param  page          page number to read packet from
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       readPage() continious where the last one
     *                       led off and it is inside a
     *                       'beginExclusive/endExclusive' block.
     * @param  readBuf       byte array to place read data into
     * @param  offset        offset into readBuf to place data
     * @param  extraInfo     byte array to put extra info read into
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void readPage(int page, boolean readContinue, byte[] readBuf,
            int offset, byte[] extraInfo) throws OneWireIOException,
            OneWireException {

        // check if current bank is not scratchpad bank, or not page 0
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (!this.extraInfo) {</span>
<span class="nc" id="L873">            throw new OneWireException(</span>
            &quot;Read extra information not supported on this memory bank&quot;);
        }

<span class="nc" id="L877">        readPageCRC(page, readContinue, readBuf, offset, extraInfo, extraInfoLength);</span>
<span class="nc" id="L878">    }</span>

    /**
     * Read a Universal Data Packet and extra information.  See the
     * method 'readPagePacket()' for a description of the packet structure.
     * See the method 'hasExtraInfo()' for a description of the optional
     * extra information some devices have.
     *
     * @param  page          page number to read packet from
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       readPagePacket() continious where the last one
     *                       stopped and it is inside a
     *                       'beginExclusive/endExclusive' block.
     * @param  readBuf       byte array to put data read. Must have at least
     *                       'getMaxPacketDataLength()' elements.
     * @param  offset        offset into readBuf to place data
     * @param  extraInfo     byte array to put extra info read into
     *
     * @return  number of data bytes written to readBuf at the offset.
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public int readPagePacket(int page, boolean readContinue, byte[] readBuf,
            int offset, byte[] extraInfo) throws OneWireIOException,
            OneWireException {

<span class="nc" id="L907">        byte[] raw_buf = new byte [pageLength];</span>

        // check if current bank is not scratchpad bank, or not page 0
<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (!this.extraInfo) {</span>
<span class="nc" id="L911">            throw new OneWireException(</span>
            &quot;Read extra information not supported on this memory bank&quot;);
        }

        // read entire page with read page CRC
<span class="nc" id="L916">        readPageCRC(page, readContinue, raw_buf, 0, extraInfo, extraInfoLength);</span>

        // check if length is realistic
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if ((raw_buf[0] &amp; 0x00FF) &gt; maxPacketDataLength) {</span>
<span class="nc" id="L920">            forceVerify();</span>

<span class="nc" id="L922">            throw new OneWireIOException(&quot;Invalid length in packet&quot;);</span>
        }

        // verify the CRC is correct
<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (CRC16.compute(raw_buf, 0, raw_buf[0] + 3, page) == 0x0000B001) {</span>

            // extract the data out of the packet
<span class="nc" id="L929">            System.arraycopy(raw_buf, 1, readBuf, offset, raw_buf [0]);</span>

            // return the length
<span class="nc" id="L932">            return raw_buf [0];</span>
        } else {
<span class="nc" id="L934">            forceVerify();</span>

<span class="nc" id="L936">            throw new OneWireIOException(&quot;Invalid CRC16 in packet read&quot;);</span>
        }
    }

    /**
     * Read a Universal Data Packet and extra information.  See the
     * method 'readPagePacket()' for a description of the packet structure.
     * See the method 'hasExtraInfo()' for a description of the optional
     * extra information some devices have.
     *
     * @param  page          page number to read packet from
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       readPagePacket() continious where the last one
     *                       stopped and it is inside a
     *                       'beginExclusive/endExclusive' block.
     * @param  readBuf       byte array to put data read. Must have at least
     *                       'getMaxPacketDataLength()' elements.
     * @param  offset        offset into readBuf to place data
     *
     * @return  number of data bytes written to readBuf at the offset.
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public int readPagePacket(int page, boolean readContinue, byte[] readBuf,
            int offset) throws OneWireIOException, OneWireException {

<span class="nc" id="L965">        byte[] raw_buf = new byte [pageLength];</span>

        // read entire page with read page CRC
<span class="nc" id="L968">        readPageCRC(page, readContinue, raw_buf, 0, null, extraInfoLength);</span>

        // check if length is realistic
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if ((raw_buf[0] &amp; 0x00FF) &gt; maxPacketDataLength) {</span>
<span class="nc" id="L972">            forceVerify();</span>

<span class="nc" id="L974">            throw new OneWireIOException(&quot;Invalid length in packet&quot;);</span>
        }

        // verify the CRC is correct
<span class="nc bnc" id="L978" title="All 2 branches missed.">        if (CRC16.compute(raw_buf, 0, raw_buf[0] + 3, page) == 0x0000B001) {</span>

            // extract the data out of the packet
<span class="nc" id="L981">            System.arraycopy(raw_buf, 1, readBuf, offset, raw_buf [0]);</span>

            // return the length
<span class="nc" id="L984">            return raw_buf [0];</span>
        } else {
<span class="nc" id="L986">            forceVerify();</span>

<span class="nc" id="L988">            throw new OneWireIOException(&quot;Invalid CRC16 in packet read&quot;);</span>
        }
    }

    /**
     * Write a Universal Data Packet.  See the method 'readPagePacket()'
     * for a description of the packet structure.
     *
     * @param  page          page number to write packet to
     * @param  writeBuf      data byte array to write
     * @param  offset        offset into writeBuf where data to write is
     * @param  len           number of bytes to write
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void writePagePacket(int page, byte[] writeBuf, int offset, int len)
            throws OneWireIOException, OneWireException {

        // make sure length does not exceed max
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        if (len &gt; maxPacketDataLength) {</span>
<span class="nc" id="L1010">            throw new OneWireIOException(</span>
            &quot;Length of packet requested exceeds page size&quot;);
        }

        // see if this bank is general read/write
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        if (!generalPurposeMemory) {</span>
<span class="nc" id="L1016">            throw new OneWireException(</span>
            &quot;Current bank is not general purpose memory&quot;);
        }

        // construct the packet to write
<span class="nc" id="L1021">        byte[] raw_buf = new byte [len + 3];</span>

<span class="nc" id="L1023">        raw_buf [0] = ( byte ) len;</span>

<span class="nc" id="L1025">        System.arraycopy(writeBuf, offset, raw_buf, 1, len);</span>

<span class="nc" id="L1027">        int crc = CRC16.compute(raw_buf, 0, len + 1, page);</span>

<span class="nc" id="L1029">        raw_buf [len + 1] = ( byte ) (~crc &amp; 0xFF);</span>
<span class="nc" id="L1030">        raw_buf [len + 2] = ( byte ) (((~crc &amp; 0xFFFF) &gt;&gt;&gt; 8) &amp; 0xFF);</span>

        // write the packet, return result
<span class="nc" id="L1033">        write(page * pageLength, raw_buf, 0, len + 3);</span>
<span class="nc" id="L1034">    }</span>

    /**
     * Read a complete memory page with CRC verification provided by the
     * device.  Not supported by all devices.  See the method
     * 'hasPageAutoCRC()'.
     *
     * @param  page          page number to read
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       readPagePacket() continious where the last one
     *                       stopped and it is inside a
     *                       'beginExclusive/endExclusive' block.
     * @param  readBuf       byte array to put data read. Must have at least
     *                       'getMaxPacketDataLength()' elements.
     * @param  offset        offset into readBuf to place data
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void readPageCRC(int page, boolean readContinue, byte[] readBuf,
            int offset) throws OneWireIOException, OneWireException {
<span class="nc" id="L1057">        readPageCRC(page, readContinue, readBuf, offset, null, extraInfoLength);</span>
<span class="nc" id="L1058">    }</span>

    /**
     * Read a complete memory page with CRC verification provided by the
     * device with extra information.  Not supported by all devices.
     * See the method 'hasPageAutoCRC()'.
     * See the method 'hasExtraInfo()' for a description of the optional
     * extra information.
     *
     * @param  page          page number to read
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       readPagePacket() continious where the last one
     *                       stopped and it is inside a
     *                       'beginExclusive/endExclusive' block.
     * @param  readBuf       byte array to put data read. Must have at least
     *                       'getMaxPacketDataLength()' elements.
     * @param  offset        offset into readBuf to place data
     * @param  extraInfo     byte array to put extra info read into
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void readPageCRC(int page, boolean readContinue, byte[] readBuf,
            int offset, byte[] extraInfo) throws OneWireIOException,
            OneWireException {
<span class="nc" id="L1085">        readPageCRC(page, readContinue, readBuf, offset, extraInfo, extraInfoLength);</span>
<span class="nc" id="L1086">    }</span>

    //--------
    //-------- OTPMemoryBank I/O methods
    //--------

    /**
     * Lock the specified page in the current memory bank.  Not supported
     * by all devices.  See the method 'canLockPage()'.
     *
     * @param  page   number of page to lock
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void lockPage(int page) throws OneWireIOException, OneWireException {

        // create byte to write to mlLock to lock page
<span class="nc" id="L1105">        int    nbyt    = (page &gt;&gt;&gt; 3);</span>
<span class="nc" id="L1106">        int    nbit    = page - (nbyt &lt;&lt; 3);</span>
<span class="nc" id="L1107">        byte[] wr_byte = new byte [1];</span>

<span class="nc" id="L1109">        wr_byte [0] = ( byte ) ~(0x01 &lt;&lt; nbit);</span>

        // bit field so turn off write verification
<span class="nc" id="L1112">        mbLock.setWriteVerification(false);</span>

        // write the lock bit
<span class="nc" id="L1115">        mbLock.write(nbyt + lockOffset, wr_byte, 0, 1);</span>

        // read back to verify
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (!isPageLocked(page))</span>
        {
<span class="nc" id="L1120">            forceVerify();</span>

<span class="nc" id="L1122">            throw new OneWireIOException(&quot;Read back from write incorrect, could not lock page&quot;);</span>
        }
<span class="nc" id="L1124">    }</span>

    /**
     * Query to see if the specified page is locked.
     * See the method 'canLockPage()'.
     *
     * @param  page  number of page to see if locked
     *
     * @return  'true' if page locked.
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public boolean isPageLocked(int page) throws OneWireIOException, OneWireException {

        // read page that locked bit is on 
<span class="nc" id="L1141">        int pg_len  = mbLock.getPageLength();</span>
<span class="nc" id="L1142">        int read_pg = (page + lockOffset) / (pg_len * 8);</span>

        // read page with bit
<span class="nc" id="L1145">        byte[] read_buf = new byte [pg_len];</span>

<span class="nc" id="L1147">        mbLock.readPageCRC(read_pg, false, read_buf, 0);</span>

        // return boolean on locked bit
<span class="nc" id="L1150">        int index = (page + lockOffset) - (read_pg * 8 * pg_len);</span>
<span class="nc" id="L1151">        int nbyt  = (index &gt;&gt;&gt; 3);</span>
<span class="nc" id="L1152">        int nbit  = index - (nbyt &lt;&lt; 3);</span>

<span class="nc bnc" id="L1154" title="All 2 branches missed.">        return !(((read_buf [nbyt] &gt;&gt;&gt; nbit) &amp; 0x01) == 0x01);</span>
    }

    /**
     * Redirect the specifed page in the current memory bank to a new page.
     * Not supported by all devices.  See the method 'canRedirectPage()'.
     *
     * @param  page      number of page to redirect
     * @param  newPage   new page number to redirect to
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void redirectPage(int page, int newPage) throws OneWireIOException, OneWireException {

        // create byte to redirect page
<span class="nc" id="L1171">        byte[] wr_byte = new byte [1];</span>

<span class="nc" id="L1173">        wr_byte [0] = ( byte ) ~newPage;</span>

        // writing byte so turn on write verification
<span class="nc" id="L1176">        mbRedirect.setWriteVerification(true);</span>

        // write the redirection byte
<span class="nc" id="L1179">        mbRedirect.write(page + redirectOffset, wr_byte, 0, 1);</span>
<span class="nc" id="L1180">    }</span>

    /**
     * Query to see if the specified page is redirected.
     * Not supported by all devices.  See the method 'canRedirectPage()'.
     *
     * @param  page      number of page check for redirection
     *
     * @return  return the new page number or 0 if not redirected
     *
     * @throws OneWireIOException
     * @throws OneWireException
     *
     * @deprecated  As of 1-Wire API 0.01, replaced by {@link #getRedirectedPage(int)}
     */
    @Override
    public int isPageRedirected(int page) throws OneWireIOException,
            OneWireException {

        // read page that redirect byte is on 
<span class="nc" id="L1200">        int pg_len  = mbRedirect.getPageLength();</span>
<span class="nc" id="L1201">        int read_pg = (page + redirectOffset) / pg_len;</span>

        // read page with byte
<span class="nc" id="L1204">        byte[] read_buf = new byte [pg_len];</span>

<span class="nc" id="L1206">        mbRedirect.readPageCRC(read_pg, false, read_buf, 0);</span>

        // return page
<span class="nc" id="L1209">        return ~read_buf [(page + redirectOffset) % pg_len] &amp; 0x000000FF;</span>
    }

    /**
     * Gets the page redirection of the specified page.
     * Not supported by all devices. 
     *
     * @param  page  page to check for redirection
     *
     * @return  the new page number or 0 if not redirected
     *
     * @throws OneWireIOException on a 1-Wire communication error such as 
     *         no device present or a CRC read from the device is incorrect.  This could be
     *         caused by a physical interruption in the 1-Wire Network due to 
     *         shorts or a newly arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException on a communication or setup error with the 1-Wire 
     *         adapter.  
     *
     * @see #canRedirectPage() canRedirectPage
     * @see #redirectPage(int,int) redirectPage
     * @since 1-Wire API 0.01
     */
    @Override
    public int getRedirectedPage(int page) throws OneWireIOException, OneWireException {

        // read page that redirect byte is on 
<span class="nc" id="L1235">        int pg_len  = mbRedirect.getPageLength();</span>
<span class="nc" id="L1236">        int read_pg = (page + redirectOffset) / pg_len;</span>

        // read page with byte
<span class="nc" id="L1239">        byte[] read_buf = new byte [pg_len];</span>

<span class="nc" id="L1241">        mbRedirect.readPageCRC(read_pg, false, read_buf, 0);</span>

        // return page
<span class="nc" id="L1244">        return ~read_buf [(page + redirectOffset) % pg_len] &amp; 0x000000FF;</span>
    }

    /**
     * Lock the redirection option for the specifed page in the current
     * memory bank. Not supported by all devices.  See the method
     * 'canLockRedirectPage()'.
     *
     * @param  page      number of page to redirect
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public void lockRedirectPage(int page) throws OneWireIOException, OneWireException {

        // create byte to write to mlLock to lock page
<span class="nc" id="L1261">        int    nbyt    = (page &gt;&gt;&gt; 3);</span>
<span class="nc" id="L1262">        int    nbit    = page - (nbyt &lt;&lt; 3);</span>
<span class="nc" id="L1263">        byte[] wr_byte = new byte [1];</span>

<span class="nc" id="L1265">        wr_byte [0] = ( byte ) ~(0x01 &lt;&lt; nbit);</span>

        // bit field so turn off write verification
<span class="nc" id="L1268">        mbLockRedirect.setWriteVerification(false);</span>

        // write the lock bit
<span class="nc" id="L1271">        mbLockRedirect.write(nbyt + lockRedirectOffset, wr_byte, 0, 1);</span>

        // read back to verify
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (!isRedirectPageLocked(page))</span>
        {
<span class="nc" id="L1276">            forceVerify();</span>

<span class="nc" id="L1278">            throw new OneWireIOException(</span>
            &quot;Read back from write incorrect, could not lock redirect byte&quot;);
        }
<span class="nc" id="L1281">    }</span>

    /**
     * Query to see if the specified page has redirection locked.
     * Not supported by all devices.  See the method 'canRedirectPage()'.
     *
     * @param  page      number of page check for locked redirection
     *
     * @return  return 'true' if redirection is locked for this page
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    @Override
    public boolean isRedirectPageLocked(int page) throws OneWireIOException, OneWireException {

        // read page that lock redirect bit is on 
<span class="nc" id="L1298">        int pg_len  = mbLockRedirect.getPageLength();</span>
<span class="nc" id="L1299">        int read_pg = (page + lockRedirectOffset) / (pg_len * 8);</span>

        // read page with bit
<span class="nc" id="L1302">        byte[] read_buf = new byte [pg_len];</span>

<span class="nc" id="L1304">        mbLockRedirect.readPageCRC(read_pg, false, read_buf, 0);</span>

        // return boolean on lock redirect bit
<span class="nc" id="L1307">        int index = (page + lockRedirectOffset) - (read_pg * 8 * pg_len);</span>
<span class="nc" id="L1308">        int nbyt  = (index &gt;&gt;&gt; 3);</span>
<span class="nc" id="L1309">        int nbit  = index - (nbyt &lt;&lt; 3);</span>

<span class="nc bnc" id="L1311" title="All 2 branches missed.">        return !(((read_buf [nbyt] &gt;&gt;&gt; nbit) &amp; 0x01) == 0x01);</span>
    }

    //--------
    //-------- Bank specific methods
    //--------

    /**
     * Read a complete memory page with CRC verification provided by the
     * device with extra information.  Not supported by all devices.
     * If not extra information available then just call with extraLength=0.
     *
     * @param  page          page number to read
     * @param  readContinue  if 'true' then device read is continued without
     *                       re-selecting.  This can only be used if the new
     *                       readPagePacket() continious where the last one
     *                       stopped and it is inside a
     *                       'beginExclusive/endExclusive' block.
     * @param  readBuf       byte array to put data read. Must have at least
     *                       'getMaxPacketDataLength()' elements.
     * @param  offset        offset into readBuf to place data
     * @param  extraInfo     byte array to put extra info read into
     * @param  extraLength   length of extra information
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    protected void readPageCRC(int page, boolean readContinue, byte[] readBuf,
            int offset, byte[] extraInfo, int extraLength)
            throws OneWireIOException, OneWireException {

<span class="nc" id="L1342">        int    len = 0, lastcrc = 0;</span>
<span class="nc" id="L1343">        byte[] raw_buf = new byte [pageLength + numCRCBytes];</span>

        // only needs to be implemented if supported by hardware
<span class="nc bnc" id="L1346" title="All 2 branches missed.">        if (!pageAutoCRC) {</span>
<span class="nc" id="L1347">            throw new OneWireException(</span>
            &quot;Read page with CRC not supported in this memory bank&quot;);
        }

        // attempt to put device at max desired speed
<span class="nc bnc" id="L1352" title="All 2 branches missed.">        if (!readContinue) {</span>
<span class="nc" id="L1353">            checkSpeed();</span>
        }

        // check if read exceeds memory
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (page &gt; numberPages) {</span>
<span class="nc" id="L1358">            throw new OneWireException(&quot;Read exceeds memory bank end&quot;);</span>
        }

        // see if need to access the device
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        if (!readContinue) {</span>

            // select the device
<span class="nc bnc" id="L1365" title="All 2 branches missed.">            if (!ib.adapter.select(ib.address)) {</span>
<span class="nc" id="L1366">                forceVerify();</span>

<span class="nc" id="L1368">                throw new OneWireIOException(&quot;Device select failed&quot;);</span>
            }

            // build start reading memory block with: command, address, (extraInfo?), (crc?)
<span class="nc" id="L1372">            len = 3 + extraInfoLength;</span>

<span class="nc bnc" id="L1374" title="All 2 branches missed.">            if (crcAfterAddress) {</span>
<span class="nc" id="L1375">                len += numCRCBytes;</span>
            }

<span class="nc" id="L1378">            System.arraycopy(ffBlock, 0, raw_buf, 0, len);</span>

<span class="nc" id="L1380">            raw_buf [0] = READ_PAGE_WITH_CRC;</span>

<span class="nc" id="L1382">            int addr = page * pageLength + startPhysicalAddress;</span>

<span class="nc" id="L1384">            raw_buf [1] = ( byte ) (addr &amp; 0xFF);</span>
<span class="nc" id="L1385">            raw_buf [2] = ( byte ) (((addr &amp; 0xFFFF) &gt;&gt;&gt; 8) &amp; 0xFF);</span>

            // do the first block 
<span class="nc" id="L1388">            ib.adapter.dataBlock(raw_buf, 0, len);</span>

<span class="nc bnc" id="L1390" title="All 2 branches missed.">        } else if (extraInfoLength &gt; 0) {</span>

            // build first block with: extraInfo, crc
<span class="nc" id="L1393">            len = extraInfoLength + numCRCBytes;</span>

<span class="nc" id="L1395">            System.arraycopy(ffBlock, 0, raw_buf, 0, len);</span>

            // do the first block 
<span class="nc" id="L1398">            ib.adapter.dataBlock(raw_buf, 0, len);</span>
        }

        // check CRC
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        if (numCRCBytes == 2) {</span>
<span class="nc" id="L1403">            lastcrc = CRC16.compute(raw_buf, 0, len, 0);</span>
        } else {
<span class="nc" id="L1405">            lastcrc = CRC8.compute(raw_buf, 0, len, 0);</span>
        }

<span class="nc bnc" id="L1408" title="All 4 branches missed.">        if ((extraInfoLength &gt; 0) || (crcAfterAddress)) {</span>

            // check CRC
<span class="nc bnc" id="L1411" title="All 2 branches missed.">            if (numCRCBytes == 2) {</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">                if (lastcrc != 0x0000B001) {</span>
<span class="nc" id="L1413">                    forceVerify();</span>

<span class="nc" id="L1415">                    throw new OneWireIOException(&quot;Invalid CRC16 read from device&quot;);</span>
                }
            } else {
<span class="nc bnc" id="L1418" title="All 2 branches missed.">                if (lastcrc != 0) {</span>
<span class="nc" id="L1419">                    forceVerify();</span>

<span class="nc" id="L1421">                    throw new OneWireIOException(&quot;Invalid CRC8 read from device&quot;);</span>
                }
            }

<span class="nc" id="L1425">            lastcrc = 0;</span>

            // extract the extra information
<span class="nc bnc" id="L1428" title="All 4 branches missed.">            if ((extraInfoLength &gt; 0) &amp;&amp; (extraInfo != null))</span>
<span class="nc" id="L1429">                System.arraycopy(raw_buf, len - extraInfoLength - numCRCBytes,</span>
                        extraInfo, 0, extraLength);
        }

        // pre-fill with 0xFF 
<span class="nc" id="L1434">        System.arraycopy(ffBlock, 0, raw_buf, 0, raw_buf.length);</span>

        // send block to read data + crc
<span class="nc" id="L1437">        ib.adapter.dataBlock(raw_buf, 0, raw_buf.length);</span>

        // check the CRC
<span class="nc bnc" id="L1440" title="All 2 branches missed.">        if (numCRCBytes == 2) {</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">            if (CRC16.compute(raw_buf, 0, raw_buf.length, lastcrc) != 0x0000B001) {</span>
<span class="nc" id="L1442">                forceVerify();</span>

<span class="nc" id="L1444">                throw new OneWireIOException(&quot;Invalid CRC16 read from device&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L1447" title="All 2 branches missed.">            if (CRC8.compute(raw_buf, 0, raw_buf.length, lastcrc) != 0) {</span>
<span class="nc" id="L1448">                forceVerify();</span>

<span class="nc" id="L1450">                throw new OneWireIOException(&quot;Invalid CRC8 read from device&quot;);</span>
            }
        }

        // extract the page data
<span class="nc" id="L1455">        System.arraycopy(raw_buf, 0, readBuf, offset, pageLength);</span>
<span class="nc" id="L1456">    }</span>

    /**
     * Program an EPROM byte at the specified address.
     *
     * @param  addr          address
     * @param  data          data byte to program
     * @param  writeContinue if 'true' then device programming is continued without
     *                       re-selecting.  This can only be used if the new
     *                       programByte() continious where the last one
     *                       stopped and it is inside a
     *                       'beginExclusive/endExclusive' block.
     *
     * @return  the echo byte after programming.  This should be the desired
     *          byte to program if the location was previously unprogrammed.
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    protected byte programByte(int addr, byte data, boolean writeContinue)
            throws OneWireIOException, OneWireException {
<span class="nc" id="L1477">        int lastcrc = 0, len;</span>

<span class="nc bnc" id="L1479" title="All 2 branches missed.">        if (!writeContinue) {</span>

            // select the device
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            if (!ib.adapter.select(ib.address)) {</span>
<span class="nc" id="L1483">                forceVerify();</span>

<span class="nc" id="L1485">                throw new OneWireIOException(&quot;device not present&quot;);</span>
            }

            // pre-fill with 0xFF 
<span class="nc" id="L1489">            byte[] raw_buf = new byte [6];</span>

<span class="nc" id="L1491">            System.arraycopy(ffBlock, 0, raw_buf, 0, raw_buf.length);</span>

            // contruct packet
<span class="nc" id="L1494">            raw_buf [0] = ( byte ) WRITE_MEMORY_COMMAND;</span>
<span class="nc" id="L1495">            raw_buf [1] = ( byte ) (addr &amp; 0xFF);</span>
<span class="nc" id="L1496">            raw_buf [2] = ( byte ) (((addr &amp; 0xFFFF) &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="nc" id="L1497">            raw_buf [3] = ( byte ) data;</span>

<span class="nc bnc" id="L1499" title="All 2 branches missed.">            if (numCRCBytes == 2) {</span>
<span class="nc" id="L1500">                lastcrc = CRC16.compute(raw_buf, 0, 4, 0);</span>
<span class="nc" id="L1501">                len     = 6;</span>
            } else {
<span class="nc" id="L1503">                lastcrc = CRC8.compute(raw_buf, 0, 4, 0);</span>
<span class="nc" id="L1504">                len     = 5;</span>
            }

            // send block to read data + crc
<span class="nc" id="L1508">            ib.adapter.dataBlock(raw_buf, 0, len);</span>

            // check CRC
<span class="nc bnc" id="L1511" title="All 2 branches missed.">            if (numCRCBytes == 2) {</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">                if (CRC16.compute(raw_buf, 4, 2, lastcrc) != 0x0000B001) {</span>
<span class="nc" id="L1513">                    forceVerify();</span>

<span class="nc" id="L1515">                    throw new OneWireIOException(&quot;Invalid CRC16 read from device&quot;);</span>
                }
            } else {
<span class="nc bnc" id="L1518" title="All 2 branches missed.">                if (CRC8.compute(raw_buf, 4, 1, lastcrc) != 0) {</span>
<span class="nc" id="L1519">                    forceVerify();</span>

<span class="nc" id="L1521">                    throw new OneWireIOException(&quot;Invalid CRC8 read from device&quot;);</span>
                }
            }
<span class="nc" id="L1524">        } else {</span>

            // send the data
<span class="nc" id="L1527">            ib.adapter.putByte(data);</span>

            // check CRC from device
<span class="nc bnc" id="L1530" title="All 2 branches missed.">            if (numCRCBytes == 2) {</span>
<span class="nc" id="L1531">                lastcrc = CRC16.compute(data, addr);</span>
<span class="nc" id="L1532">                lastcrc = CRC16.compute(ib.adapter.getByte(), lastcrc);</span>

<span class="nc bnc" id="L1534" title="All 2 branches missed.">                if (CRC16.compute(ib.adapter.getByte(), lastcrc) != 0x0000B001) {</span>
<span class="nc" id="L1535">                    forceVerify();</span>

<span class="nc" id="L1537">                    throw new OneWireIOException(&quot;Invalid CRC16 read from device&quot;);</span>
                }
            } else {
<span class="nc" id="L1540">                lastcrc = CRC8.compute(data, addr);</span>

<span class="nc bnc" id="L1542" title="All 2 branches missed.">                if (CRC8.compute(ib.adapter.getByte(), lastcrc) != 0) {</span>
<span class="nc" id="L1543">                    forceVerify();</span>

<span class="nc" id="L1545">                    throw new OneWireIOException(&quot;Invalid CRC8 read from device&quot;);</span>
                }
            }
        }

        // send the pulse 
<span class="nc" id="L1551">        ib.adapter.startProgramPulse(DSPortAdapter.CONDITION_NOW);</span>

        // return the result
<span class="nc" id="L1554">        return ( byte ) ib.adapter.getByte();</span>
    }

    //--------
    //-------- checkSpeed methods
    //--------

    /**
     * Check the device speed if has not been done before or if
     * an error was detected.
     *
     * @throws OneWireIOException
     * @throws OneWireException
     */
    public synchronized void checkSpeed() throws OneWireIOException, OneWireException {

        // only check the speed
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        if (doSetSpeed) {</span>

            // attempt to set the correct speed and verify device present
<span class="nc" id="L1574">            ib.doSpeed();</span>

            // no execptions so clear flag
<span class="nc" id="L1577">            doSetSpeed = false;</span>
        }
<span class="nc" id="L1579">    }</span>

    /**
     * Set the flag to indicate the next 'checkSpeed()' will force
     * a speed set and verify 'doSpeed()'.
     */
    public synchronized void forceVerify () {
<span class="nc" id="L1586">        doSetSpeed = true;</span>
<span class="nc" id="L1587">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>