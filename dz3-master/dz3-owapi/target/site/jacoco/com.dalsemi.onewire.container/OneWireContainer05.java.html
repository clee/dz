<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OneWireContainer05.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OWAPI 1.00 refactored for DIY Zoning</a> &gt; <a href="index.source.html" class="el_package">com.dalsemi.onewire.container</a> &gt; <span class="el_source">OneWireContainer05.java</span></div><h1>OneWireContainer05.java</h1><pre class="source lang-java linenums">
/*---------------------------------------------------------------------------
 * Copyright (C) 1999,2000 Dallas Semiconductor Corporation, All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL DALLAS SEMICONDUCTOR BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Dallas Semiconductor
 * shall not be used except as stated in the Dallas Semiconductor
 * Branding Policy.
 *---------------------------------------------------------------------------
 */

package com.dalsemi.onewire.container;

import com.dalsemi.onewire.adapter.DSPortAdapter;
import com.dalsemi.onewire.adapter.OneWireIOException;
import com.dalsemi.onewire.OneWireException;


/**
 * &lt;P&gt; 1-Wire&amp;#174 container for a Single Addressable Switch, DS2405.  This container
 * encapsulates the functionality of the 1-Wire family type &lt;B&gt;05&lt;/B&gt; (hex)&lt;/P&gt;
 *
 * &lt;H3&gt; Features &lt;/H3&gt;
 * &lt;UL&gt;
 *   &lt;LI&gt; Open drain PIO pin controlled through 1-Wire communication
 *   &lt;LI&gt; Logic level sensing of the PIO pin can be sensed
 *   &lt;LI&gt; Operating temperature range from -40&amp;#176C to
 *        +85&amp;#176C
 *   &lt;li&gt; One channel with level sensing abilities
 *   &lt;li&gt; Does not support activity sensing or 'Smart On' capabilities
 * &lt;/UL&gt;
 *
 * &lt;H3&gt; Memory &lt;/H3&gt;
 *
 * &lt;P&gt; The DS2405 has no memory beyond its 64-bit registration number. &lt;/P&gt;
 *
 *
 * &lt;H3&gt; Usage &lt;/H3&gt;
 *
 * &lt;p&gt;The DS2405 supports level sensing, but not activity sensing.  The code below
 * reads the state of the DS2405, extracting the latch state and the sensed level
 * of the PIO pin, then in the loop it toggles the latch state.&lt;/p&gt;
 *
 * &lt;code&gt;&lt;pre&gt;
 *      // &quot;ID&quot; is a byte array of size 8 with an address of a part we
 *      // have already found with family code 05 hex
 *      // &quot;access&quot; is a DSPortAdapter
 *
 *      int i=0;
 *      OneWireContainer05 ds2405 = (OneWireContainer05) access.getDeviceContainer(ID);
 *      ds2405.setupContainer(access,ID);
 *
 *      byte[] state = ds2405.readDevice();
 *
 *      // I know that the 2405 only has one channel (one switch)
 *      // and it doesn't support 'Smart On'
 *
 *      boolean latch_state = ds2405.getLatchState(0,state);
 *      System.out.println(&quot;Current state of switch: &quot;+latch_state);
 *      System.out.println(&quot;Current output level:    &quot;+ds2405.getLevel(0,state));
 *      while (++i &amp;lt; 100)
 *      {
 *          System.out.println(&quot;Toggling switch&quot;);
 *          ds2405.setLatchState(0,!latch_state,false,state);
 *          ds2405.writeDevice(state);
 *          state = ds2405.readDevice();
 *          latch_state = ds2405.getLatchState(0,state);
 *          System.out.println(&quot;Current state of switch: &quot;+latch_state);
 *          System.out.println(&quot;Current output level:    &quot;+ds2405.getLevel(0,state));
 *          Thread.sleep(500);
 *      }
 *
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * &lt;p&gt;Also see the usage example in the {@link com.dalsemi.onewire.container.SwitchContainer SwithContainer}
 * interface.&lt;/p&gt;
 *
 * &lt;H3&gt; DataSheet &lt;/H3&gt;
 * &lt;DL&gt;
 * &lt;DD&gt;&lt;A HREF=&quot;http://pdfserv.maxim-ic.com/arpdf/DS2405.pdf&quot;&gt; http://pdfserv.maxim-ic.com/arpdf/DS2405.pdf&lt;/A&gt;
 * &lt;/DL&gt;
 *
 * Also see the {@link com.dalsemi.onewire.container.OneWireContainer12 DS2406}, a dual addressable switch (OneWireContainer12).
 *
 * @see com.dalsemi.onewire.container.OneWireSensor
 * @see com.dalsemi.onewire.container.SwitchContainer
 * @see com.dalsemi.onewire.container.OneWireContainer12
 *
 *  @version    0.00, 28 Aug 2000
 *  @author     KLA,DSS
 * @author Stability enhancements &amp;copy; &lt;a href=&quot;mailto:vt@freehold.crocodile.org&quot;&gt; Vadim Tkachenko&lt;/a&gt; 2001-2009
 */
public class OneWireContainer05 extends OneWireContainer implements SwitchContainer {

    //--------
    //-------- Constructors
    //--------

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2405.
     * Note that the method &lt;code&gt;setupContainer(com.dalsemi.onewire.adapter.DSPortAdapter,byte[])&lt;/code&gt;
     * must be called to set the correct &lt;code&gt;DSPortAdapter&lt;/code&gt; device address.
     *
     * @see com.dalsemi.onewire.container.OneWireContainer#setupContainer(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) setupContainer(DSPortAdapter,byte[])
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) OneWireContainer05(DSPortAdapter,byte[])
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,long) OneWireContainer05(DSPortAdapter,long)
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,java.lang.String) OneWireContainer05(DSPortAdapter,String)
     */
<span class="nc" id="L126">    public OneWireContainer05() {</span>
<span class="nc" id="L127">    }</span>

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2405.
     *
     * @param  sourceAdapter     adapter object required to communicate with
     * this 1-Wire device
     * @param  newAddress        address of this DS2405
     *
     * @see #OneWireContainer05()
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,long) OneWireContainer05(DSPortAdapter,long)
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,java.lang.String) OneWireContainer05(DSPortAdapter,String)
     */
    public OneWireContainer05(DSPortAdapter sourceAdapter, byte[] newAddress) {
<span class="nc" id="L141">        super(sourceAdapter, newAddress);</span>
<span class="nc" id="L142">    }</span>

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2405.
     *
     * @param  sourceAdapter     adapter object required to communicate with
     * this 1-Wire device
     * @param  newAddress        address of this DS2405
     *
     * @see #OneWireContainer05()
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) OneWireContainer05(DSPortAdapter,byte[])
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,java.lang.String) OneWireContainer05(DSPortAdapter,String)
     */
    public OneWireContainer05(DSPortAdapter sourceAdapter, long newAddress) {
<span class="nc" id="L156">        super(sourceAdapter, newAddress);</span>
<span class="nc" id="L157">    }</span>

    /**
     * Creates a new &lt;code&gt;OneWireContainer&lt;/code&gt; for communication with a DS2405.
     *
     * @param  sourceAdapter     adapter object required to communicate with
     * this 1-Wire device
     * @param  newAddress        address of this DS2405
     *
     * @see #OneWireContainer05()
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,byte[]) OneWireContainer05(DSPortAdapter,byte[])
     * @see #OneWireContainer05(com.dalsemi.onewire.adapter.DSPortAdapter,long) OneWireContainer05(DSPortAdapter,long)
     */
    public OneWireContainer05(DSPortAdapter sourceAdapter, String newAddress) {
<span class="nc" id="L171">        super(sourceAdapter, newAddress);</span>
<span class="nc" id="L172">    }</span>

    //--------
    //-------- Methods
    //--------

    /**
     * Gets the Dallas Semiconductor part number of the iButton
     * or 1-Wire Device as a &lt;code&gt;java.lang.String&lt;/code&gt;.
     * For example &quot;DS1992&quot;.
     *
     * @return iButton or 1-Wire device name
     */
    @Override
    public String getName() {
<span class="nc" id="L187">        return &quot;DS2405&quot;;</span>
    }

    /**
     * Retrieves the alternate Dallas Semiconductor part numbers or names.
     * A 'family' of MicroLAN devices may have more than one part number
     * depending on packaging.  There can also be nicknames such as
     * &quot;Crypto iButton&quot;.
     *
     * @return  the alternate names for this iButton or 1-Wire device
     */
    @Override
    public String getAlternateNames() {
<span class="nc" id="L200">        return &quot;Addressable Switch&quot;;</span>
    }

    /**
     * Gets a short description of the function of this iButton
     * or 1-Wire Device type.
     *
     * @return device description
     */
    @Override
    public String getDescription() {
<span class="nc" id="L211">        return &quot;Addressable Switch with controlled open drain PIO &quot;</span>
        + &quot;pin. PIO pin sink capability is greater than 4mA &quot;
        + &quot;at 0.4V.&quot;;
    }

    //--------
    //-------- Switch Feature methods
    //--------

    /**
     * Gets the number of channels supported by this switch.
     * Channel specific methods will use a channel number specified
     * by an integer from [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)].  Note that
     * all devices of the same family will not necessarily have the
     * same number of channels.
     *
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return the number of channels for this device
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     */
    @Override
    public int getNumberChannels(byte[] state) {
        // we ignore the state, DS2405 can only have one channel
<span class="nc" id="L236">        return 1;</span>
    }

    /**
     * Checks if the channels of this switch are 'high side'
     * switches.  This indicates that when 'on' or &lt;code&gt;true&lt;/code&gt;, the switch output is
     * connect to the 1-Wire data.  If this method returns  &lt;code&gt;false&lt;/code&gt;
     * then when the switch is 'on' or &lt;code&gt;true&lt;/code&gt;, the switch is connected
     * to ground.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the switch is a 'high side' switch,
     *         &lt;code&gt;false&lt;/code&gt; if the switch is a 'low side' switch
     *
     * @see #getLatchState(int,byte[])
     */
    @Override
    public boolean isHighSideSwitch() {
<span class="nc" id="L253">        return false;</span>
    }

    /**
     * Checks if the channels of this switch support
     * activity sensing.  If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;getSensedActivity(int,byte[])&lt;/code&gt; can be used.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channels support activity sensing
     *
     * @see #getSensedActivity(int,byte[])
     * @see #clearActivity()
     */
    @Override
    public boolean hasActivitySensing() {
<span class="nc" id="L268">        return false;</span>
    }

    /**
     * Checks if the channels of this switch support
     * level sensing.  If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;getLevel(int,byte[])&lt;/code&gt; can be used.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channels support level sensing
     *
     * @see #getLevel(int,byte[])
     */
    @Override
    public boolean hasLevelSensing() {
<span class="nc" id="L282">        return true;</span>
    }

    /**
     * Checks if the channels of this switch support
     * 'smart on'. Smart on is the ability to turn on a channel
     * such that only 1-Wire device on this channel are awake
     * and ready to do an operation.  This greatly reduces
     * the time to discover the device down a branch.
     * If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;setLatchState(int,boolean,boolean,byte[])&lt;/code&gt;
     * can be used with the &lt;code&gt;doSmart&lt;/code&gt; parameter &lt;code&gt;true&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channels support 'smart on'
     *
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean hasSmartOn() {
<span class="nc" id="L301">        return false;</span>
    }

    /**
     * Checks if the channels of this switch require that only one
     * channel is on at any one time.  If this method returns &lt;code&gt;true&lt;/code&gt; then the
     * method &lt;code&gt;setLatchState(int,boolean,boolean,byte[])&lt;/code&gt;
     * will not only affect the state of the given
     * channel but may affect the state of the other channels as well
     * to insure that only one channel is on at a time.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if only one channel can be on at a time.
     *
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    public boolean onlySingleChannelOn() {
<span class="nc" id="L317">        return true;</span>
    }

    //--------
    //-------- Switch 'get' Methods
    //--------

    /**
     * Checks the sensed level on the indicated channel.
     * To avoid an exception, verify that this switch
     * has level sensing with the  &lt;code&gt;hasLevelSensing()&lt;/code&gt;.
     * Level sensing means that the device can sense the logic
     * level on its PIO pin.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if level sensed is 'high' and &lt;code&gt;false&lt;/code&gt; if level sensed is 'low'
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #hasLevelSensing()
     */
    @Override
    public boolean getLevel(int channel, byte[] state) {
<span class="nc bnc" id="L341" title="All 2 branches missed.">        return ((state[0] &amp; 0x02) == 0x02);</span>
    }

    /**
     * Checks the latch state of the indicated channel.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if channel latch is 'on'
     * or conducting and &lt;code&gt;false&lt;/code&gt; if channel latch is 'off' and not
     * conducting.  Note that the actual output when the latch is 'on'
     * is returned from the &lt;code&gt;isHighSideSwitch()&lt;/code&gt; method.
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #isHighSideSwitch()
     * @see #setLatchState(int,boolean,boolean,byte[])
     */
    @Override
    public boolean getLatchState(int channel, byte[] state) {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        return ((state[0] &amp; 0x01) == 0x01);</span>
    }

    /**
     * Checks if the indicated channel has experienced activity.
     * This occurs when the level on the PIO pins changes.  To clear
     * the activity that is reported, call &lt;code&gt;clearActivity()&lt;/code&gt;.
     * To avoid an exception, verify that this device supports activity
     * sensing by calling the method &lt;code&gt;hasActivitySensing()&lt;/code&gt;.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if activity was detected and &lt;code&gt;false&lt;/code&gt; if no activity was detected
     *
     * @throws OneWireException if this device does not have activity sensing
     *
     * @see #hasActivitySensing()
     * @see #clearActivity()
     */
    @Override
    public boolean getSensedActivity(int channel, byte[] state)
            throws OneWireException {

        // i don't do this
<span class="nc" id="L386">        throw new OneWireException(address, &quot;Sense Activity not supported&quot;);</span>
    }

    /**
     * Clears the activity latches the next time possible.  For
     * example, on a DS2406/07, this happens the next time the
     * status is read with &lt;code&gt;readDevice()&lt;/code&gt;.
     *
     * @throws OneWireException if this device does not support activity sensing
     *
     * @see com.dalsemi.onewire.container.OneWireSensor#readDevice()
     * @see #getSensedActivity(int,byte[])
     */
    @Override
    public void clearActivity() throws OneWireException {

        //i don't do this
<span class="nc" id="L403">        throw new OneWireException(address, &quot;Sense Activity not supported&quot;);</span>
    }

    //--------
    //-------- Switch 'set' Methods
    //--------

    /**
     * Sets the latch state of the indicated channel.
     * The method &lt;code&gt;writeDevice()&lt;/code&gt; must be called to finalize
     * changes to the device.  Note that multiple 'set' methods can
     * be called before one call to &lt;code&gt;writeDevice()&lt;/code&gt;.
     *
     * @param channel channel to execute this operation, in the range [0 to (&lt;code&gt;getNumberChannels(byte[])&lt;/code&gt; - 1)]
     * @param latchState &lt;code&gt;true&lt;/code&gt; to set the channel latch 'on'
     *     (conducting) and &lt;code&gt;false&lt;/code&gt; to set the channel latch 'off' (not
     *     conducting).  Note that the actual output when the latch is 'on'
     *     is returned from the &lt;code&gt;isHighSideSwitch()&lt;/code&gt; method.
     * @param doSmart If latchState is 'on'/&lt;code&gt;true&lt;/code&gt; then doSmart indicates
     *                  if a 'smart on' is to be done.  To avoid an exception
     *                  check the capabilities of this device using the
     *                  &lt;code&gt;hasSmartOn()&lt;/code&gt; method.
     * @param state current state of the device returned from &lt;code&gt;readDevice()&lt;/code&gt;
     *
     * @see #hasSmartOn()
     * @see #getLatchState(int,byte[])
     * @see com.dalsemi.onewire.container.OneWireSensor#writeDevice(byte[])
     */
    @Override
    public void setLatchState(int channel, boolean latchState, boolean doSmart, byte[] state) {
        
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (latchState) {</span>
<span class="nc" id="L435">            state [0] = ( byte ) (state [0] | 0x01);</span>
        } else {
<span class="nc" id="L437">            state [0] = ( byte ) (state [0] &amp; 0xfe);</span>
        }
<span class="nc" id="L439">    }</span>

    /**
     * Retrieves the 1-Wire device sensor state.  This state is
     * returned as a byte array.  Pass this byte array to the 'get'
     * and 'set' methods.  If the device state needs to be changed then call
     * the 'writeDevice' to finalize the changes.
     *
     * @return 1-Wire device sensor state
     *
     * @throws OneWireIOException on a 1-Wire communication error such as
     *         reading an incorrect CRC from a 1-Wire device.  This could be
     *         caused by a physical interruption in the 1-Wire Network due to
     *         shorts or a newly arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException on a communication or setup error with the 1-Wire
     *         adapter
     * @deprecated Use {@link #readDevice(byte[])} instead, it doesn't allocate memory.
     */
    @Override
    public byte[] readDevice() throws OneWireIOException, OneWireException {

        //this ain't a hard part--it's only gonna take 1 byte
<span class="nc" id="L461">        byte[] state = new byte [1];</span>

<span class="nc" id="L463">        readDevice(state);</span>

<span class="nc" id="L465">        return state;</span>
    }

    @Override
    public void readDevice(byte[] state) throws OneWireIOException, OneWireException {

        //first let's make sure we can talk to the part
        //speed is not critical with the 2405 so i'll just call doSpeed()
<span class="nc" id="L473">        doSpeed();</span>

        //here's the 'bitmap'
        //bit 0 :   switch state (0 for conducting, 1 for non-conducting)
        //bit 1 :   sensed level (0 for low, 1 for high)
<span class="nc" id="L478">        state [0] = ( byte ) 0;</span>

<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (isPresent()) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (isAlarming()) {</span>
<span class="nc" id="L482">                state [0] = 1;</span>
            }
        } else {
<span class="nc" id="L485">            throw new OneWireIOException(address, &quot;Device not present&quot;);</span>
        }

<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (isPresent()) {</span>

            // Byte after 'search' indicates level
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (adapter.getByte() != 0) {</span>
<span class="nc" id="L492">                state [0] = ( byte ) (state [0] | 0x02);</span>
            }
        } else {
<span class="nc" id="L495">            throw new OneWireIOException(address, &quot;Device not present&quot;);</span>
        }
<span class="nc" id="L497">    }</span>

    /**
     * Writes the 1-Wire device sensor state that
     * have been changed by 'set' methods.  Only the state registers that
     * changed are updated.  This is done by referencing a field information
     * appended to the state data.
     *
     * @param  state 1-Wire device sensor state
     *
     * @throws OneWireIOException on a 1-Wire communication error such as
     *         reading an incorrect CRC from a 1-Wire device.  This could be
     *         caused by a physical interruption in the 1-Wire Network due to
     *         shorts or a newly arriving 1-Wire device issuing a 'presence pulse'.
     * @throws OneWireException on a communication or setup error with the 1-Wire
     *         adapter
     */
    @Override
    public void writeDevice(byte[] state) throws OneWireIOException, OneWireException {

<span class="nc" id="L517">        doSpeed();</span>

<span class="nc bnc" id="L519" title="All 2 branches missed.">        boolean value   = ((state [0] &amp; 0x01) == 0x01);</span>
<span class="nc" id="L520">        boolean compare = isAlarming();</span>

        // check to see if already in the correct state
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (compare == value) {</span>
<span class="nc" id="L524">            return;</span>
        }

        // incorrect state so toggle
<span class="nc bnc" id="L528" title="All 2 branches missed.">        else if (adapter.select(address)) {</span>

            // verify
<span class="nc" id="L531">            compare = isAlarming();</span>

<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (compare == value) {</span>
<span class="nc" id="L534">                return;</span>
            }
        }

<span class="nc" id="L538">        throw new OneWireIOException(address, &quot;Failure to change DS2405 latch state&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>