<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MqttConnector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MQTT Connector</a> &gt; <a href="index.source.html" class="el_package">net.sf.dz3.view.mqtt.v1</a> &gt; <span class="el_source">MqttConnector.java</span></div><h1>MqttConnector.java</h1><pre class="source lang-java linenums">package net.sf.dz3.view.mqtt.v1;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonReader;
import javax.json.JsonString;

import org.apache.logging.log4j.ThreadContext;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;

import net.sf.dz3.device.model.Thermostat;
import net.sf.dz3.device.model.impl.ThermostatModel;
import net.sf.dz3.device.sensor.Addressable;
import net.sf.dz3.device.sensor.AnalogSensor;
import net.sf.dz3.device.sensor.Switch;
import net.sf.dz3.scheduler.Scheduler;
import net.sf.dz3.view.Connector;
import net.sf.dz3.view.ConnectorFactory;
import net.sf.jukebox.jmx.JmxDescriptor;

/**
 * MQTT broker interface.
 *
 * This object is supposed to be instantiated via Spring configuration file, with objects
 * that are supposed to be rendered and/or controlled being present in a set passed to the constructor.
 *
 * See {@code net.sf.dz3.view.swing.Console} for more information.
 *
 * {@code init-method=&quot;start&quot;} attribute must be used in Spring bean definition, otherwise
 * the connector will not work.
 *
 * @see MqttDeviceFactory
 *
 * @author Copyright &amp;copy; &lt;a href=&quot;mailto:vt@freehold.crocodile.org&quot;&gt;Vadim Tkachenko&lt;/a&gt; 2001-2020
 */
public class MqttConnector extends Connector&lt;JsonRenderer&gt; {

    /**
     * @see SensorRenderer#render(net.sf.jukebox.datastream.signal.model.DataSample)
     * @see SwitchRenderer#render(net.sf.jukebox.datastream.signal.model.DataSample)
     * @see ThermostatRenderer#render(net.sf.jukebox.datastream.signal.model.DataSample)
     */
<span class="nc" id="L55">    static enum EntityType {</span>

<span class="nc" id="L57">        SENSOR,</span>
<span class="nc" id="L58">        SWITCH,</span>
<span class="nc" id="L59">        THERMOSTAT;</span>

        @Override
        public String toString() {
<span class="nc" id="L63">            return super.toString().toLowerCase();</span>
        }
    }

    private final MqttContext mqtt;
<span class="nc" id="L68">    private final BlockingQueue&lt;UpstreamBlock&gt; upstreamQueue = new LinkedBlockingQueue&lt;UpstreamBlock&gt;();</span>

    private Thread exchanger;

    /**
     * Unauthenticated constructor with a default port.
     *
     * @param mqttBrokerHost Host to connect to.
     * @param mqttRootTopicPub Root topic to publish to.
     * @param mqttRootTopicSub Root topic to subscribe to.
     * @param initSet Entities to publish the status of.
     */
    public MqttConnector(
            String mqttBrokerHost,
            String mqttRootTopicPub, String mqttRootTopicSub,
            Set&lt;Object&gt; initSet) throws MqttException {

<span class="nc" id="L85">        this(mqttBrokerHost, MqttContext.DEFAULT_PORT, null, null, mqttRootTopicPub, mqttRootTopicSub, initSet, null);</span>
<span class="nc" id="L86">    }</span>

    /**
     * Unauthenticated constructor with a custom port.
     *
     * @param mqttBrokerHost Host to connect to.
     * @param mqttBrokerPort Port to connect to.
     * @param mqttRootTopicPub Root topic to publish to.
     * @param mqttRootTopicSub Root topic to subscribe to.
     * @param initSet Entities to publish the status of.
     */
    public MqttConnector(
            String mqttBrokerHost, int mqttBrokerPort,
            String mqttRootTopicPub, String mqttRootTopicSub,
            Set&lt;Object&gt; initSet) throws MqttException {

<span class="nc" id="L102">        this(mqttBrokerHost, mqttBrokerPort, null, null, mqttRootTopicPub, mqttRootTopicSub, initSet, null);</span>
<span class="nc" id="L103">    }</span>

    /**
     * Authenticated constructor with a default port.
     *
     * @param mqttBrokerHost Host to connect to.
     * @param port Port to connect to.
     * @param mqttBrokerUsername MQTT broker username.
     * @param mqttBrokerPassword MQTT broker password.
     * @param mqttRootTopicPub Root topic to publish to.
     * @param mqttRootTopicSub Root topic to subscribe to.
     * @param initSet Entities to publish the status of.
     */
    public MqttConnector(
            String mqttBrokerHost,
            String mqttBrokerUsername, String mqttBrokerPassword,
            String mqttRootTopicPub, String mqttRootTopicSub,
            Set&lt;Object&gt; initSet) throws MqttException {

<span class="nc" id="L122">        this(mqttBrokerHost, MqttContext.DEFAULT_PORT, mqttBrokerUsername, mqttBrokerPassword, mqttRootTopicPub, mqttRootTopicSub, initSet, null);</span>
<span class="nc" id="L123">    }</span>

    /**
     * Authenticated constructor with a custom port.
     *
     * @param mqttBrokerHost Host to connect to.
     * @param mqttBrokerPort Port to connect to.
     * @param mqttBrokerUsername MQTT broker username.
     * @param mqttBrokerPassword MQTT broker password.
     * @param mqttRootTopicPub Root topic to publish to.
     * @param mqttRootTopicSub Root topic to subscribe to.
     * @param initSet Entities to publish the status of.
     */
    public MqttConnector(
            String mqttBrokerHost, int mqttBrokerPort,
            String mqttBrokerUsername, String mqttBrokerPassword,
            String mqttRootTopicPub, String mqttRootTopicSub,
            Set&lt;Object&gt; initSet) throws MqttException {

<span class="nc" id="L142">        this(mqttBrokerHost, mqttBrokerPort, mqttBrokerUsername, mqttBrokerPassword, mqttRootTopicPub, mqttRootTopicSub, initSet, null);</span>
<span class="nc" id="L143">    }</span>

    /**
     * Authenticated constructor with a default port and custom factory set.
     *
     * @param mqttBrokerHost Host to connect to.
     * @param mqttBrokerUsername MQTT broker username.
     * @param mqttBrokerPassword MQTT broker password.
     * @param mqttRootTopicPub Root topic to publish to.
     * @param mqttRootTopicSub Root topic to subscribe to.
     * @param initSet Entities to publish the status of.
     * @param factorySet Set of component connector factories.
     */
    public MqttConnector(
            String mqttBrokerHost,
            String mqttBrokerUsername, String mqttBrokerPassword,
            String mqttRootTopicPub, String mqttRootTopicSub,
            Set&lt;Object&gt; initSet,
            Set&lt;ConnectorFactory&lt;JsonRenderer&gt;&gt; factorySet) throws MqttException {

<span class="nc" id="L163">        this(mqttBrokerHost, MqttContext.DEFAULT_PORT, mqttBrokerUsername, mqttBrokerPassword, mqttRootTopicPub, mqttRootTopicSub, initSet, factorySet);</span>
<span class="nc" id="L164">    }</span>

    /**
     * Authenticated constructor with a default port and custom factory set.
     *
     * @param mqttBrokerHost Host to connect to.
     * @param mqttBrokerPort Port to connect to.
     * @param mqttBrokerUsername MQTT broker username.
     * @param mqttBrokerPassword MQTT broker password.
     * @param mqttRootTopicPub Root topic to publish to.
     * @param mqttRootTopicSub Root topic to subscribe to.
     * @param initSet Entities to publish the status of.
     * @param factorySet Set of component connector factories.
     */
    public MqttConnector(
            String mqttBrokerHost, int mqttBrokerPort,
            String mqttBrokerUsername, String mqttBrokerPassword,
            String mqttRootTopicPub, String mqttRootTopicSub,
            Set&lt;Object&gt; initSet,
            Set&lt;ConnectorFactory&lt;JsonRenderer&gt;&gt; factorySet) throws MqttException {

<span class="nc" id="L185">        super(initSet, factorySet);</span>

<span class="nc" id="L187">        this.mqtt = new MqttContext(</span>
                mqttBrokerHost, mqttBrokerPort,
                mqttBrokerUsername, mqttBrokerPassword,
                mqttRootTopicPub, mqttRootTopicSub, new Callback());

<span class="nc" id="L192">        checkTopics(mqttRootTopicPub, mqttRootTopicSub);</span>

<span class="nc" id="L194">        register(AnalogSensor.class, new SensorFactory());</span>
<span class="nc" id="L195">        register(Switch.class, new SwitchFactory());</span>
<span class="nc" id="L196">        register(ThermostatModel.class, new ThermostatFactory(resolveScheduler(initSet)));</span>
<span class="nc" id="L197">    }</span>


    /**
     * Make sure topic name combination is sane.
     *
     * @param topicPub Name of the topic to publish to.
     * @param topicSub Name of the topic to subscribe to.
     */
    private void checkTopics(String topicPub, String topicSub) {

        // Only one of the topics needs to be present; but both being null doesn't make sense -
        // might just as well remove the object from the configuration altogether

<span class="nc bnc" id="L211" title="All 4 branches missed.">        if (topicPub == null &amp;&amp; topicSub == null) {</span>
<span class="nc" id="L212">            throw new IllegalArgumentException(&quot;both publishing and subscription topics are nulls&quot;);</span>
        }

        // Same topic name for publishing and subscriptions is likely to cause a runaway loop

<span class="nc bnc" id="L217" title="All 4 branches missed.">        if (topicPub != null &amp;&amp; topicPub.equals(topicSub)) {</span>
<span class="nc" id="L218">            throw new IllegalArgumentException(</span>
                    &quot;same topic (&quot; + topicPub + &quot;) for both publishing and subscription, &quot; +
                    &quot;runaway loop is likely&quot;);
        }
<span class="nc" id="L222">    }</span>

    private Scheduler resolveScheduler(Set&lt;Object&gt; source) {

<span class="nc bnc" id="L226" title="All 2 branches missed.">        for (Iterator&lt;Object&gt; i = source.iterator(); i.hasNext(); ) {</span>

<span class="nc" id="L228">            Object item = i.next();</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (item instanceof Scheduler) {</span>

<span class="nc" id="L232">                logger.info(&quot;Using scheduler: &quot; + item);</span>
<span class="nc" id="L233">                return (Scheduler) item;</span>
            }
<span class="nc" id="L235">        }</span>

<span class="nc" id="L237">        logger.warn(&quot;No scheduler provided, no schedule deviations will be reported to remote controls&quot;);</span>

<span class="nc" id="L239">        return null;</span>
    }

    @Override
    public JmxDescriptor getJmxDescriptor() {

<span class="nc" id="L245">        return new JmxDescriptor(</span>
                &quot;dz&quot;,
<span class="nc" id="L247">                getClass().getSimpleName(),</span>
                mqtt.host
<span class="nc bnc" id="L249" title="All 2 branches missed.">                + (mqtt.port == MqttContext.DEFAULT_PORT ? &quot;&quot; : &quot; port &quot; + mqtt.port)</span>
                + &quot; topic/pub &quot; + mqtt.rootTopicPub
                + &quot; topic/sub &quot; + mqtt.rootTopicSub,
                &quot;MQTT Connector v1&quot;);
    }

    @Override
    protected Map&lt;String, Object&gt; createContext() {

<span class="nc" id="L258">        Map&lt;String, Object&gt; context = new TreeMap&lt;String, Object&gt;();</span>

<span class="nc" id="L260">        context.put(QueueFeeder.QUEUE_KEY, upstreamQueue);</span>
<span class="nc" id="L261">        return context;</span>
    }

    @Override
    protected synchronized void activate2() {

        try {

<span class="nc" id="L269">            mqtt.start();</span>
<span class="nc" id="L270">            startExchanger();</span>

            // Connectors are initialized very late in the game, it is likely that the control logic
            // has been long activated - but it is also likely that there will be no new events for
            // quite a while. Need to send all the data that we have to listeners so they can act on it.

<span class="nc" id="L276">            flush();</span>

<span class="nc" id="L278">        } catch (Throwable t) {</span>

<span class="nc" id="L280">            throw new IllegalStateException(&quot;failed to start&quot;, t);</span>
<span class="nc" id="L281">        }</span>
<span class="nc" id="L282">    }</span>

    /**
     * Send the status of all {@link #getInitSet() initSet} objects into the transport.
     */
    private void flush() {

<span class="nc" id="L289">        ThreadContext.push(&quot;flush&quot;);</span>

        try {

            // VT: NOTE: This is an ugly hack. The connector architecture was never intended
            // to poll object status, only to handle events broadcast from upstream.

<span class="nc bnc" id="L296" title="All 2 branches missed.">            for (Iterator&lt;Object&gt; i = getInitSet().iterator(); i.hasNext(); ) {</span>

<span class="nc" id="L298">                Object source = i.next();</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (source instanceof Switch) {</span>

<span class="nc" id="L302">                    flush((Switch) source);</span>
<span class="nc" id="L303">                    continue;</span>
                }

                // VT: NOTE: Flushing sensor data is not that important, it will be handled normally
                // next time sensors are polled or come up with samples. Thermostats will follow
                // immediately thereafter.

                // VT: FIXME: Other entities (namely, HvacController, HvacDriver, ZoneController, Unit)
                // will need to be flushed eventually, when/if they will be capable to be independently
                // controlled without violating DZ abstractions.

<span class="nc" id="L314">                logger.warn(&quot;don't know how to flush: &quot; + source.getClass().getName() + &quot;: &quot; + source);</span>
<span class="nc" id="L315">            }</span>

        } finally {
<span class="nc" id="L318">            ThreadContext.pop();</span>
        }
<span class="nc" id="L320">    }</span>

    private void flush(Switch source) {

<span class="nc" id="L324">        ThreadContext.push(&quot;flush&quot;);</span>

        try {

<span class="nc" id="L328">            logger.info(source);</span>
<span class="nc" id="L329">            source.setState(source.getState());</span>

<span class="nc" id="L331">        } catch (IOException ex) {</span>
<span class="nc" id="L332">            logger.error(&quot;failed to flush, ignored (nothing we can do now): &quot; + source, ex);</span>
        } finally {
<span class="nc" id="L334">            ThreadContext.pop();</span>
        }
<span class="nc" id="L336">    }</span>

    private void startExchanger() {

<span class="nc" id="L340">        exchanger = new Thread(new UpstreamBlockExchanger(mqtt.host, mqtt.port, mqtt.rootTopicPub, upstreamQueue));</span>

<span class="nc" id="L342">        exchanger.start();</span>
<span class="nc" id="L343">    }</span>

    @Override
    protected synchronized void deactivate2() {

<span class="nc" id="L348">        ThreadContext.push(&quot;deactivate2&quot;);</span>

        try {

<span class="nc" id="L352">            exchanger.interrupt();</span>
<span class="nc" id="L353">            mqtt.disconnect();</span>

<span class="nc" id="L355">        } catch (MqttException ex) {</span>

<span class="nc" id="L357">            logger.error(&quot;can't disconnect, nor can do anything about it&quot;, ex);</span>
        } finally {
<span class="nc" id="L359">            ThreadContext.pop();</span>
        }
<span class="nc" id="L361">    }</span>

    private class UpstreamBlockExchanger extends ImmediateExchanger&lt;UpstreamBlock&gt; {

        private final String mqttRootTopicPub;

        public UpstreamBlockExchanger(
                String mqttBrokerHost, int mqttBrokerPort,
                String mqttRootTopicPub,
<span class="nc" id="L370">                BlockingQueue&lt;UpstreamBlock&gt; upstreamQueue) {</span>
<span class="nc" id="L371">            super(upstreamQueue);</span>

<span class="nc" id="L373">            this.mqttRootTopicPub = mqttRootTopicPub;</span>
<span class="nc" id="L374">        }</span>

        @Override
        protected void send(UpstreamBlock dataBlock) throws IOException {

<span class="nc" id="L379">            ThreadContext.push(&quot;send&quot;);</span>

            try {

<span class="nc" id="L383">                MqttMessage message = new MqttMessage(dataBlock.payload.getBytes());</span>

<span class="nc" id="L385">                message.setQos(mqtt.QOS);</span>
<span class="nc" id="L386">                message.setRetained(true);</span>

<span class="nc" id="L388">                mqtt.publish(mqttRootTopicPub + &quot;/&quot; + dataBlock.topic, message);</span>

<span class="nc" id="L390">                logger.debug(mqttRootTopicPub + &quot;/&quot; + dataBlock.topic + &quot;: &quot; + dataBlock.payload);</span>

<span class="nc" id="L392">            } catch (MqttException ex) {</span>

<span class="nc" id="L394">                logger.error(&quot;can't publish, ignored, is this a persistent error?&quot;, ex);</span>

            } finally {
<span class="nc" id="L397">                ThreadContext.pop();</span>
            }
<span class="nc" id="L399">        }</span>
    }

<span class="nc" id="L402">    private class Callback implements MqttCallback {</span>

        /**
         * Mapping from HA's {@code entity_id} to {@code friendly_name}
         * (which must match our name so we can match their entity to ours).
         */
<span class="nc" id="L408">        private final Map&lt;String, String&gt; entityId2name = new TreeMap&lt;&gt;();</span>

        /**
         * Mapping from known &quot;friendly name&quot; to our entity.
         * {@code null} value indicates that we know this name, but it is not our entity.
         */
<span class="nc" id="L414">        private final Map&lt;String, Object&gt; name2entity = new TreeMap&lt;&gt;();</span>

        @Override
        public void connectionLost(Throwable cause) {

            // VT: FIXME: Currently, this code does NOT support reconnects.
<span class="nc" id="L420">            logger.fatal(</span>
<span class="nc" id="L421">                    &quot;connection to tcp://&quot; + mqtt.host + &quot;:&quot; + mqtt.port +</span>
                    &quot; lost, will not reconnect, MQTT interface is now dead&quot;);
<span class="nc" id="L423">        }</span>

        /**
         * Attempt to parse incoming messages as Home Assistant MQTT event stream.
         *
         * @see https://www.home-assistant.io/components/mqtt_eventstream/
         */
        @Override
        public void messageArrived(String topic, MqttMessage message) throws Exception {

<span class="nc" id="L433">            ThreadContext.push(&quot;MQTT/messageArrived&quot;);</span>

            try {

<span class="nc" id="L437">                logger.debug(topic + &quot; &quot; + message);</span>

<span class="nc" id="L439">                try (JsonReader reader = Json.createReader(new ByteArrayInputStream(message.getPayload()))) {</span>

<span class="nc" id="L441">                    JsonObject payload = reader.readObject();</span>
<span class="nc" id="L442">                    JsonString eventType = payload.getJsonString(MqttContext.JsonTag.EVENT_TYPE.name);</span>

                    // We know and care about two event types at this point:
                    //
                    // call_service: somebody moved a slider
                    // state_changed: something changed

<span class="nc bnc" id="L449" title="All 3 branches missed.">                    switch (eventType.getString()) {</span>

                    case &quot;call_service&quot;:

<span class="nc" id="L453">                        callService(payload.getJsonObject(MqttContext.JsonTag.EVENT_DATA.name));</span>
<span class="nc" id="L454">                        return;</span>

                    case &quot;state_changed&quot;:

<span class="nc" id="L458">                        stateChanged(payload.getJsonObject(MqttContext.JsonTag.EVENT_DATA.name));</span>
<span class="nc" id="L459">                        return;</span>

                    default:

<span class="nc" id="L463">                        logger.warn(&quot;don't know how to handle '&quot; + eventType + &quot;' event_type&quot;);</span>
<span class="nc" id="L464">                        logger.warn(&quot;event_data is:&quot; + payload.getJsonObject(MqttContext.JsonTag.EVENT_DATA.name));</span>

<span class="nc" id="L466">                        return;</span>
                    }
<span class="nc bnc" id="L468" title="All 4 branches missed.">                }</span>

<span class="nc" id="L470">            } catch (Throwable t) {</span>

                // VT: NOTE: According to the docs, throwing an exception here will shut down the client - can't afford that,
                // so we'll just complain loudly

<span class="nc" id="L475">                logger.error(&quot;MQTT message caused an exception: &quot; + message, t);</span>

            } finally {
<span class="nc" id="L478">                ThreadContext.pop();</span>
            }
<span class="nc" id="L480">        }</span>

        /**
         * Handle HA's {@code call_service} message.
         *
         * @param eventData HA's {@code event_data} JSON fragment.
         */
        private void callService(JsonObject eventData) {

<span class="nc" id="L489">            ThreadContext.push(&quot;callService&quot;);</span>

            try {

<span class="nc" id="L493">                logger.info(&quot;data: &quot; + eventData);</span>

                // Since this is a control input, let's be paranoid and verify that it contains what we expect

<span class="nc" id="L497">                String domain = eventData.getJsonString(&quot;domain&quot;).getString();</span>
<span class="nc" id="L498">                String service = eventData.getJsonString(&quot;service&quot;).getString();</span>

<span class="nc bnc" id="L500" title="All 4 branches missed.">                if (!&quot;climate&quot;.equals(domain) || !&quot;set_temperature&quot;.equals(service)) {</span>

<span class="nc" id="L502">                    throw new IllegalArgumentException(</span>
                            &quot;invalid command: expected (climate, set_temperature)&quot; +
                            &quot;, received (&quot;+ domain + &quot;, &quot; + service + &quot;)&quot;);
                }

<span class="nc" id="L507">                String entityId = eventData.</span>
<span class="nc" id="L508">                        getJsonObject(&quot;service_data&quot;).</span>
<span class="nc" id="L509">                        getJsonString(&quot;entity_id&quot;).getString();</span>
<span class="nc" id="L510">                Object entity = resolveEntity(entityId);</span>

<span class="nc bnc" id="L512" title="All 2 branches missed.">                if (entity == null) {</span>

                    // VT: NOTE: This is expected behavior in case the entity is not ours
                    // we've already logged this at debug level, let's just remind ourselves about that

<span class="nc" id="L517">                    logger.info(entityId + &quot;: not ours; our known map is: &quot; + entityId2name);</span>
<span class="nc" id="L518">                    return;</span>
                }

<span class="nc" id="L521">                logger.info(&quot;resolved entity: &quot; + entity);</span>

<span class="nc bnc" id="L523" title="All 2 branches missed.">                if (!(entity instanceof ThermostatModel)) {</span>

<span class="nc" id="L525">                    throw new IllegalStateException(&quot;not a thermostat, but &quot; + entity.getClass().getName() + &quot;: &quot; + entity);</span>
                }

<span class="nc" id="L528">                double setpoint = eventData.</span>
<span class="nc" id="L529">                        getJsonObject(&quot;service_data&quot;).</span>
<span class="nc" id="L530">                        getJsonNumber(&quot;temperature&quot;).doubleValue();</span>

<span class="nc" id="L532">                logger.info(&quot;setpoint: &quot; + setpoint);</span>

<span class="nc" id="L534">                ((ThermostatModel) entity).setSetpoint(setpoint);</span>

            } finally {
<span class="nc" id="L537">                ThreadContext.pop();</span>
            }
<span class="nc" id="L539">        }</span>

        /**
         * Handle HA's {@code call_service} message.
         *
         * We are only interested in this message as it is an echo of the message we sent to it earlier;
         * we will use it to figure out the {@code entity_id} we'll need to recognize later.
         *
         * @param eventData HA's {@code event_data} JSON fragment.
         */
        private void stateChanged(JsonObject eventData) {

<span class="nc" id="L551">            ThreadContext.push(&quot;stateChanged&quot;);</span>

            try {

<span class="nc" id="L555">                logger.debug(&quot;data: &quot; + eventData);</span>

                // We need two elements now:
                //
                // .event_data.entity_id
                // .event_data.new_state.attributes.friendly_name

<span class="nc" id="L562">                String entityId = eventData.getJsonString(&quot;entity_id&quot;).getString();</span>
<span class="nc" id="L563">                String friendlyName = eventData.</span>
<span class="nc" id="L564">                        getJsonObject(&quot;new_state&quot;).</span>
<span class="nc" id="L565">                        getJsonObject(&quot;attributes&quot;).</span>
<span class="nc" id="L566">                        getJsonString(&quot;friendly_name&quot;).getString();</span>
<span class="nc" id="L567">                String knownName = entityId2name.get(entityId);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">                if (entityId2name.get(entityId) == null) {</span>

<span class="nc" id="L571">                    logger.info(&quot;new entity discovered: &quot; + entityId + &quot;: &quot; + friendlyName);</span>

                    // Since call_service event will only contain entity_id, we'll need to map it
                    // back to our entity later

<span class="nc" id="L576">                    entityId2name.put(entityId, friendlyName);</span>

<span class="nc bnc" id="L578" title="All 2 branches missed.">                } else if (!knownName.equals(friendlyName)) {</span>

<span class="nc" id="L580">                    logger.warn(entityId + &quot;: old and new name mismatch ('&quot; + knownName + &quot;' vs. '&quot;+ friendlyName + &quot;', ignored&quot;);</span>
                }

<span class="nc" id="L583">                Object entity = resolveEntity(entityId);</span>

<span class="nc bnc" id="L585" title="All 2 branches missed.">                if (entity == null) {</span>

                    // VT: NOTE: This is expected behavior in case the entity is not ours;
                    // we've already logged this at debug level. No need to do anything

<span class="nc" id="L590">                    return;</span>
                }

<span class="nc bnc" id="L593" title="All 2 branches missed.">                if (entity instanceof Thermostat) {</span>

                    // VT: NOTE: This must be an echo from our own state change broadcast.
                    // We will only honor callService() for our own thermostats.

<span class="nc" id="L598">                    return;</span>
                }

                // VT: FIXME: handle the message
<span class="nc" id="L602">                logger.error(&quot;Not Implemented: &quot; + entity, new IllegalStateException());</span>

            } finally {
<span class="nc" id="L605">                ThreadContext.pop();</span>
            }
<span class="nc" id="L607">        }</span>

        /**
         * Resolve our entity from the ID given.
         *
         * @param entityId Entity ID to resolve.
         *
         * @return Our object corresponding to {@code entity_id} received in {@link #callService(JsonObject)}
         */
        private Object resolveEntity(String entityId) {

<span class="nc" id="L618">            ThreadContext.push(&quot;resolveEntity&quot;);</span>

            try {

<span class="nc" id="L622">                String entityName = entityId2name.get(entityId);</span>

<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (entityName == null) {</span>

<span class="nc" id="L626">                    logger.warn(&quot;unknown entity_id: '&quot; + entityId + &quot;', our known maps are:&quot;);</span>
<span class="nc" id="L627">                    logger.warn(&quot;id to name: &quot; + entityId2name);</span>
<span class="nc" id="L628">                    logger.warn(&quot;name to entity: &quot; + name2entity);</span>

<span class="nc" id="L630">                    throw new IllegalArgumentException(&quot;unknown entity_id: '&quot; + entityId + &quot;', did everything settle?&quot;);</span>
                }

<span class="nc" id="L633">                Object cached = name2entity.get(entityName);</span>

<span class="nc bnc" id="L635" title="All 2 branches missed.">                if (cached != null) {</span>

<span class="nc" id="L637">                    logger.debug(&quot;cached instance: &quot; + entityName);</span>
<span class="nc" id="L638">                    return cached;</span>
                }

<span class="nc bnc" id="L641" title="All 2 branches missed.">                if (name2entity.containsKey(entityName)) {</span>

<span class="nc" id="L643">                    logger.debug(&quot;we know about '&quot; + entityName + &quot;', but it isn't ours&quot;);</span>
<span class="nc" id="L644">                    return null;</span>
                }

<span class="nc bnc" id="L647" title="All 2 branches missed.">                for (Object entity : getInitSet()) {</span>

                    // VT: NOTE: This is where things get complicated. Our entities were never supposed to be
                    // resolved from outside. See https://github.com/home-climate-control/dz/issues/87 for details.

                    // For now, let's do it piecemeal, and then unify when the issue above is addressed.

<span class="nc bnc" id="L654" title="All 2 branches missed.">                    if (entity instanceof Addressable) {</span>

<span class="nc" id="L656">                        String name = ((Addressable) entity).getAddress();</span>

<span class="nc bnc" id="L658" title="All 2 branches missed.">                        if (name.equals(entityName)) {</span>

<span class="nc" id="L660">                            logger.info(&quot;resolved '&quot; + entityId + &quot;' into &quot; + entity);</span>
<span class="nc" id="L661">                            name2entity.put(entityName, entity);</span>

<span class="nc" id="L663">                            return entity;</span>
                        }

<span class="nc bnc" id="L666" title="All 2 branches missed.">                    } else if (entity instanceof Thermostat) {</span>

<span class="nc" id="L668">                        String name = ((Thermostat) entity).getName();</span>

<span class="nc bnc" id="L670" title="All 2 branches missed.">                        if (name.equals(entityName)) {</span>

<span class="nc" id="L672">                            logger.info(&quot;resolved '&quot; + entityId + &quot;' into &quot; + entity);</span>
<span class="nc" id="L673">                            name2entity.put(entityName, entity);</span>

<span class="nc" id="L675">                            return entity;</span>
                        }

<span class="nc" id="L678">                    } else {</span>

                        // VT: FIXME: We won't control anything other than thermostats at this point.
<span class="nc" id="L681">                        logger.warn(&quot;don't know how to handle: &quot; + entity.getClass().getName());</span>
                    }
<span class="nc" id="L683">                }</span>

                // VT: NOTE: No need to be throwing exceptions here, it may be the entity that is not present
                // in our instance, but is present in our deployment

<span class="nc" id="L688">                logger.warn(&quot;unresolved entity: '&quot; + entityId + &quot;', our known map is: &quot; + name2entity);</span>

                // And let's make a note of it
<span class="nc" id="L691">                name2entity.put(entityName, null);</span>

<span class="nc" id="L693">                return null;</span>

            } finally {
<span class="nc" id="L696">                ThreadContext.pop();</span>
            }
        }

        @Override
        public void deliveryComplete(IMqttDeliveryToken token) {

            // VT: NOTE: Nothing to do here
<span class="nc" id="L704">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>